# 写在前面

## 前言
它从一个架子鼓开始。 2019年夏天，我的一个朋友用电子套件让我打鼓，我全心全意地接受了。有时我会实际演奏鼓，但我花费了相当多的时间来编写代码，以使用 MIDI SysEx 命令与我的架子鼓配置进行交互。

当 COVID-19 大流行来袭时，在考虑当地教会的视听需求方面，我突然有了不同的优先事项，既是在我们远程敬拜时，也是在考虑如何再次见面。这包括学习 VISCA、NDI 和 OSC（用于摄像机和音频混音器）等协议，以及与 Zoom、VLC、PowerPoint、Stream Deck 等更多面向软件的集成。

这些项目没有大量的业务逻辑。几乎所有的代码都是集成代码，这既令人沮丧又非常强大。这令人沮丧，因为协议的文档模糊不清，或者不是真正为我想要实现的用途而设计，或者只是彼此不一致。它是强大的，因为一旦你解决了集成方面的问题，你就可以非常轻松地编写有用的应用程序，站在多个巨头的肩膀上。

虽然我在过去几年的经验主要是本地集成，但同样的挫败感和授权平衡也适用于 Web API。我每次使用新的 Web API 的经历都会产生一种情绪反应曲线，包括兴奋、困惑、烦恼、接受和最终不安的平静。一旦你彻底理解了一个强大的 API，感觉就像你是一个宏伟管弦乐队的指挥，准备演奏你提供的任何音乐——即使小提琴手的音符最终是一致的，你必须使用不同颜色的指挥棒对于黄铜部分，没有明显的原因。

本书不会自行改变这一点。它只是一本书。但是，如果你阅读并遵循其指导，则可以帮助改变用户的体验。如果有很多人阅读并遵循它的指导，我们可能会一起朝着更一致、更少令人沮丧的 Web API 体验迈进。

重要的是要理解这本书的价值，而不是其各部分的总和。对于 J J 深入研究的任何一个方面，任何给定的团队都可以做出合理的选择（尽管可能会错过这里指出的一些极端情况）。由于上下文的要求有限，对于特定情况，这种选择甚至可能比本书中提供的建议更好。这种方法实现了许多局部最优决策，但是一个高度分散的大局，可能会采用几种不同的方法，即使是同一家公司内的 API。

除了针对任何给定问题的一致性之外，本书还提供了跨 API 设计的多个领域的一致方法。 API 设计人员很少有空间深入思考这个问题，我认为自己很幸运能与 J J 和其他人（特别是 Luke Sneeringer）一起讨论书中的许多主题。我很高兴谷歌在 API 设计方面的投资可以通过这本书和 https://aip.dev 上的 AIP 系统为其他开发人员带来红利。

虽然我对这本书的价值充满信心，但它并没有让设计一个伟大的 API 变得容易。相反，它消除了 API 设计带来的许多附带的复杂性，让你可以专注于你想要构建的 API 真正独特的方面。你仍然应该期望必须思考并努力思考，但相信这种思考的结果可以是一个令人愉悦的 API。你的用户可能永远不会明确地感谢你；精心设计的 API 往往是显而易见的，尽管它是大量辛勤工作的结果。但是你可以在晚上睡个好觉，因为他们不会经历 API 感觉不太对劲的挫折，即使它有效。

> 用这本书作为脚凳，帮助你的 API 成为一个巨人，为他人提供可以站立的肩膀。
>
> —Jon Skeet，Google 员工开发者关系工程师

## 前言
在学校，我们学习计算机科学的方式与学习物理定律的方式相同。我们使用 大 O 表示法分析了运行时和空间复杂度，了解了各种排序算法的工作原理，并探索了遍历二叉树的不同方式。所以正如你想象的那样，毕业后，我希望我的日常工作主要是科学和数学方面的。但是想象一下当我发现事实并非如此时我的惊讶。

结果证明，我要做的大部分工作更多地是关于设计、结构和美学，而不是数学和算法。我从不需要考虑使用哪种排序算法，因为有一个库（通常是类似 array.sort() 的库）。但是，我确实必须仔细考虑我将创建的类、这些类中存在的函数以及每个函数将接受的参数。这比我预期的要困难得多。

在现实世界中，我了解到完美优化的代码远不如精心设计的代码有价值。事实证明，对于 Web API 来说更是如此，因为它们通常拥有更广泛的受众和更广泛的用例。

但这引出了一个问题：软件"精心设计"意味着什么？什么是"精心设计的 Web API"？在相当长的一段时间里，我不得不依靠几乎随意收集的资源来回答这些问题。对于某些主题，可能会有一些有趣的博客文章探讨了当今使用的一些流行替代方案。对于其他人来说，Stack Overflow 上可能有一个特别有用的答案，可以指导我朝着正确的方向前进。但在很多情况下，关于所讨论主题的材料相对较少，我只能尝试自己想出答案，并希望我的同事不要太讨厌它。

多年之后（带着一本封面上写着"可怕的 API 问题"的笔记本），我终于决定是时候写下我收集到的所有第一手信息了。起初，这是我和 Luke Sneeringer 为 Google 制定的一套规则，最终成为 AIP.dev。但是这些规则读起来有点像法律书；他们说你应该做什么，但没有说你为什么要那样做。经过大量研究并一遍又一遍地问自己这个确切的问题，这本书在这里介绍了这些规则，同时也解释了原因。

尽管这本书能够成为世界 API 设计问题的最终解决方案，但遗憾的是，我认为情况并非如此。原因很简单：就像建筑一样，任何类型的设计通常都是见仁见智的。这意味着你们中的一些人可能认为这些指导方针是美丽而优雅的，并将它们用于你未来的所有项目。同时，你们中的一些人可能认为这本书提供了可怕且过于严格的设计，并以此作为构建 Web API 时不应做的示例。因为我不能让每个人都开心，所以我唯一的目标是提供一套经过实战考验的指导方针，以及对他们为什么看起来如此的合乎逻辑的解释。

你是否将它们用作遵循或避免的示例取决于你。至少，我希望本书中涵盖的主题能在这个迷人、复杂和错综复杂的 API 设计世界中引发许多对话和相当多的未来工作。

## 致谢
与我的大部分工作一样，本书是许多不同人做出许多贡献的结果。首先，我要感谢我的妻子 Ka-el，在努力完成这份手稿的收尾工作时，她听了我的咆哮和抱怨。如果不是她坚定不移的支持，这本书很有可能已经被放弃了。此外，还有许多其他人扮演了类似的角色，包括 Kristen Ranieri、Becky Susel、Janette Clarke、Norris Clarke、Tahj Clarke、Sheryn Chan、Asfia Fazal 和 Adama Diallo，我非常感谢他们。

API 爱好者的核心团队在审查和辩论本书涵盖的主题以及提供高级指导方面发挥了重要作用。我要特别感谢 Eric Brewer、Hong Zhang、Luke Sneeringer、Jon Skeet、Alfred Fuller、Angie Lin、Thibaud Hottelier、Garrett Jones、Tim Burks、Mak Ahmad、Carlos O'Ryan、Marsh Gardiner、Mike Kistler、Eric Wheeler 、Max Ross、Marc Jacobs、Jason Woodard、Michael Rubin、Milo Martin、Brad Meyers、Sam McVeety、Rob Clevenger、Mike Schwartz、Lewis Daly、Michael Richards 和 Brian Grant 多年来提供的所有帮助。

许多其他人通过他们自己的独立工作间接为本书做出了贡献，为此我必须感谢 Roy Fielding，"四人帮"（Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides）、Sanjay Ghemawatt、Urs Hoelzle、Andrew菲克斯、肖恩昆兰和拉里格林菲尔德。我还要感谢 Stu Feldman、Ari Balogh、Rich Sanzi、Joerg Heilig、Eyal Manor、Yury Izrailevsky、Walt Drummond、Caesar Sengupta 和 Patrick Teo 在 Google 探索这些主题时给予的支持和指导。

特别感谢 Dave Nagle，他是我在广告、云、API 等领域的所有工作的拥护者，并鼓励我超越自己的舒适区。还要感谢 Mark Chadwick，他在 10 多年前帮助我克服了 API 设计中的冒名顶替综合症。他的建设性反馈和客气话是我决定深入研究计算机科学这一有趣领域的重要原因。此外，还要特别感谢 Mark Hammond，他首先教会我质疑一切，即使是在不舒服的时候。

如果没有 Manning 的编辑团队，特别是 Mike Stephens 和 Marjan Bace，他们同意本书的最初想法，以及 Christina Taylor 和我一起进行另一个长期项目，这个项目是不可能实现的。我也很感谢 Al Krinker 对章节的详细评论；我的项目编辑，Deirdre Hiam；文案编辑，米歇尔·米切尔；校对员，Keri Hales；和审稿编辑，Ivan Martinović。感谢曼宁所有帮助实现这一目标的人。

致所有评论者：Akshat Paul、Anthony Cramp、Brian Daley、Chris Heneghan、Daniel Bretoi、David J. Biesack、Deniz Vehbi、Gerardo Lecaros、Jean Lazarou、John C. Gunvaldson、Jorge Ezequiel Bo、Jort Rodenburg、Luke Kupka、Mark Nenadov、Rahul Rai、Richard Young、Roger Dowell、Ruben Vandeginste、Satej Kumar Sahu、Steven Smith、Yul Williams、Yurii Bodarev 和 Zoheb Ainapore，你的建议有助于使这本书变得更好。

## 关于这本书
API 设计模式旨在为构建 Web API 提供一组安全、灵活、可重用的模式。它首先涵盖了一些通用设计原则，并以此为基础展示了一组设计模式，旨在为构建 API 时的常见场景提供简单的解决方案。

### 谁应该读这本书

API 设计模式适用于正在构建或计划构建 Web API 的任何人，尤其是当该 API 将向公众公开时。熟悉一些序列化格式（例如 JSON、Google Protocol Buffers 或 Apache Thrift）或常见的存储范例（例如关系数据库模式）当然很好，但绝不是必需的。如果你已经熟悉 HTTP 及其各种方法（例如 GET 和 POST），这也是一个不错的奖励，因为它是本书示例中的首选传输方式。如果你发现自己在设计 API 并遇到问题并思考"我敢肯定有人已经解决了这个问题"，那么这本书适合你。

### 本书的组织方式：路线图
本书分为六部分，前两部分涵盖了 API 设计中更一般的主题，接下来的四部分专门介绍设计模式本身。

第 1 部分首先为本书的其余部分奠定了基础，并为 Web API 本身以及我们将来将应用于这些 Web API 的设计模式提供了一些定义和评估框架。

- 第 1 章首先定义了 API 的含义以及 API 的重要性。它还为我们如何评估 API 的真正质量提供了各种框架。
- 第 2 章通过查看如何将设计模式应用于 API 并解释它们如何对构建它们的任何人有用，对第 1 章进行了扩展。它涵盖了 API 设计模式的剖析，以及一个简短的案例研究，说明如何使用这些设计模式之一可以导致整体更好的 API。

第 2 部分旨在通过概述在构建任何 API 时应考虑的一些通用设计原则，在第 1 部分建立的阶段的基础上进一步构建。

- 第 3 章着眼于我们可能需要在 API 中命名的所有不同组件，以及在为它们选择名称时要考虑的因素。它还显示了命名是多么重要，尽管它看起来很肤浅。
- 第 4 章深入挖掘更大的 API，其中我们可能有多个相互关联的资源。在决定资源及其关系时，经过一些要问的问题之后，它通过介绍一些要避免的事情的例子来结束。
- 第 5 章探讨如何在 API 中使用不同的数据类型和这些数据类型的默认值。它涵盖了最常见的数据类型，如字符串和数字，以及更复杂的可能性，如地图和列表。

第 3 部分标志着设计模式目录的开始，从应该适用于几乎所有 API 的基本模式开始。

- 第 6 章密切关注 API 用户如何识别资源，深入研究标识符的低级细节，例如墓碑、字符集和编码，并使用校验和来区分丢失的 ID 和无效的 ID。
- 第 7 章详细概述了 Web API 的不同标准方法（获取、列出、创建、更新和删除）应该如何工作。它还解释了为什么每个标准方法在所有资源中都以完全相同的方式运行而不是为了适应每个资源的独特方面而变化如此重要。
- 第 8 章扩展了两个特定的标准方法（get 和 update），以解决用户如何与资源的一部分而不是整个事物进行交互。它解释了为什么这是必要和有用的（对于用户和 API），以及如何保持对这个功能的支持尽可能少的干扰。
- 第 9 章超越了标准方法，并为使用自定义方法的 API 中可能需要的任何类型的操作打开了大门。特别强调说明自定义方法何时有意义（以及何时没有意义），以及如何在你自己的 API 中做出此决定。
- 第 10 章探讨了 API 方法可能不是即时的这种独特场景，以及如何以一种方便的方式为需要长时间运行的操作 (LRO) 的用户提供支持。它探讨了 LRO 的工作原理以及 LRO 可以支持的所有方法，包括暂停、恢复和取消长时间运行的工作。
- 第 11 章涵盖了反复执行的工作的概念，有点像 Web API 的 cron 作业。它解释了如何使用执行资源并按计划或按需运行这些资源。

第 4 部分侧重于资源以及它们如何相互关联，有点像对第 4 章的更广泛的探索。

- 第 12 章解释了如何将相关数据的小而孤立的位分离到单独的子资源中。它详细介绍了何时这是一个好主意以及何时不是一个好主意的情况。
- 第 13 章概述了 Web API 中的资源应如何使用引用指针或内联值存储对其他资源的引用。它还解释了如何在引用数据随时间变化时处理边缘情况行为，例如级联删除或更新。
- 第 14 章扩展了资源之间的一对一关系，并解释了如何使用关联资源来表示多对多关系。它还涵盖了如何存储有关这些关系的元数据。
- 第 15 章着眼于在处理多对多关系时使用添加和删除快捷方法作为依赖关联资源的替代方法。它还涵盖了使用这些方法时的一些权衡以及为什么它们可能并不总是理想的选择。
- 第 16 章着眼于多态的复杂概念，其中变量可以采用各种不同的类型。它涵盖了如何处理 API 资源上的多态字段以及为什么应该避免使用多态方法。

第 5 部分超越了一次只涉及一个 API 资源的交互，开始研究旨在与整个资源集合交互的 API 设计模式。

- 第 17 章解释了如何在 API 中复制或移动资源。它解决了细微的复杂问题，例如处理外部数据、从不同父级继承的元数据以及应如何处理子资源。
- 第 18 章探讨了如何调整标准方法（获取、创建、更新和删除）以对资源集合进行操作，而不是一次对单个资源进行操作。它还涵盖了一些棘手的部分，例如应如何返回结果以及如何处理部分失败。
- 第 19 章扩展了第 17 章中批量删除方法的思想，以删除匹配特定过滤器而不仅仅是特定标识符的资源。它还探讨了如何解决一致性问题和最佳实践以避免意外破坏数据。
- 第 20 章仔细研究了非资源数据的摄取，这些数据本身不能直接寻址。它涵盖了如何使用匿名写入以及一致性主题以及这种类型的匿名数据摄取何时适合 API 的权衡。
- 第 21 章解释了如何使用分页处理浏览大型数据集，依靠不透明的页面标记来遍历数据。它还演示了如何在单个大型资源中使用分页。
- 第 22 章着眼于如何处理将过滤条件应用于列出资源以及在 API 中表示这些过滤器的最佳方式。这直接适用于第 19 章所涵盖的主题。
- 第 23 章探讨了如何处理从 API 中导入和导出资源。它还深入探讨了导入和导出操作与备份和恢复之间的细微差别。

第 6 部分重点介绍 API 中安全性和保障性方面不太令人兴奋的领域。这意味着确保 API 不受攻击者的攻击，而且提供的 API 方法不会受到用户自己的错误的影响。

- 第 24 章探讨了版本控制的主题以及不同版本相互兼容意味着什么。它深入探讨了兼容性作为一个频谱的概念以及在 API 中保持一致的兼容性策略定义的重要性。
- 第 25 章通过提供一种模式（软删除）来开始保护用户免受自身侵害的工作，该模式允许将资源从视图中删除而不是从系统中完全删除。
- 第 26 章尝试使用请求标识符来保护系统免受重复操作。它探讨了使用请求 ID 的陷阱以及确保在大型系统中正确处理这些 ID 的算法。
- 第 27 章重点介绍验证请求，这些请求允许用户在不执行底层操作的情况下预览 API 中的操作。它还探讨了如何在实时请求和验证请求期间处理更高级的主题，例如副作用。
- 第 28 章介绍了资源修订的想法，作为跟踪随时间变化的一种方式。它还涵盖了基本操作，例如恢复到以前的修订，以及更高级的主题，例如如何将修订应用于层次结构中的子资源。
- 第 29 章介绍了一种通知用户何时应重试 API 请求的模式。它还包括有关不同 HTTP 响应代码以及重试它们是否安全的指南。
- 第 30 章探讨了对单个请求进行身份验证的主题以及在 API 中对用户进行身份验证时要考虑的不同安全标准。它提出了一个规范，用于对 API 请求进行数字签名，该规范遵循安全最佳实践，以确保 API 请求具有可验证的来源和完整性，并且以后无法拒绝。

## 关于代码
本书包含许多源代码示例，包括编号列表和普通文本。在这两种情况下，源代码都以这种固定宽度的字体进行格式化，以将其与普通文本分开。有时，代码也会以粗体显示，以突出显示与本章先前步骤不同的代码，例如新功能添加到现有代码行时。

在许多情况下，原始源代码已被重新格式化；我们添加了换行符和重新设计的缩进，以适应书中可用的页面空间。在极少数情况下，这还不够，列表还包括行继续标记 (➥)。此外，当在文本中描述代码时，源代码中的注释经常从列表中删除。代码注释伴随着许多清单，突出了重要的概念。

在与我们的早期读者和审核团队进行了大量讨论后，出于各种原因，我决定使用 TypeScript 作为标准语言。首先，对于熟悉动态语言（如 JavaScript 或 Python）和静态语言（如 Java 或 C++）的任何人来说，TypeScript 都很容易理解。此外，虽然它可能不是每个人都喜欢，也不是所有的读者都能立即编写自己的 TypeScript 代码，但代码片段可以视为伪代码，大多数软件开发人员应该能够辨别其含义。

在使用 TypeScript 定义 API 时，有两个部分需要解决：资源和方法。对于前者，TypeScript 的原语（例如: 接口）在为 API 资源定义模式时非常具有表现力，使 API 定义保持足够短，几乎总是只适合几行。因此，所有 API 资源都被定义为 TypeScript 接口，这有一个额外的好处，就是使 JSON 表示非常明显。

对于 API 方法，问题稍微复杂一些。在这种情况下，我选择使用 TypeScript 抽象类来表示总体 API 本身，并使用抽象函数来定义 API 方法，遵循 Google 的 Protocol Buffers 的 RPC 常用的约定。这提供了只定义 API 方法而不必担心底层实现的能力。

在考虑 API 方法的输入和输出时，我决定再次依赖 Protocol Buffers 来获得灵感，考虑请求和响应接口。这意味着在大多数情况下，会有代表这些输入和输出的接口，命名为带有 -Request 或 -Response 后缀的 API 方法（例如: CreateChatRooom API 方法的 CreateChatRoomRequest）。

最后，由于本书在很大程度上依赖于 RESTful 概念，因此必须有一种将这些 RPC 映射到 URL（和 HTTP 方法）的方法。为此，我选择使用 TypeScript 装饰器作为各种 API 方法的注释，每种不同的 HTTP 方法（例如: @get、@post、@delete）使用一个装饰器。为了指示 API 方法应该映射到的 URL 路径，每个装饰器都接受一个模板字符串，该字符串还支持请求接口中变量的通配符。例如: @get("/{id=chatRooms/*}") 将填充请求中的 ID 字段。在这种情况下，星号表示除正斜杠字符之外的任何值的占位符。

尽管所有这些设计模式都依赖于 OpenAPI 规范，但也有一些问题往往会对本书的读者造成伤害。首先，OpenAPI 规范主要供计算机使用（例如: 代码生成器、文档渲染器等）。由于本书的目标是将复杂的 API 设计主题传达给其他 API 设计人员，因此 OpenAPI 似乎并不是实现该目标的最佳选择。

其次，虽然 OpenAPI 是一个了不起的项目，但无论我们以 YAML 还是 JSON 格式表示 API，它都非常冗长。不幸的是，使用 OpenAPI 表示这些复杂的主题是完全可能的，但不是最简洁的选择，会导致相当多的额外内容而没有增加太多价值。

最后，在 OpenAPI、Protocol Buffers 和 TypeScript 之间，早期的读者和评论者给出了非常明确的反馈，即 TypeScript 选项最适合这个特定用例。请记住，我并不提倡人们使用 TypeScript 来定义他们的 API。它非常适合这个项目。

### 线上讨论区

购买 API 设计模式包括免费访问由 Manning Publications 运营的私人网络论坛，你可以在那里对本书发表评论、提出技术问题并从作者和其他用户那里获得帮助。要访问论坛，请访问 https://livebook.manning.com/book/api-design-patterns/welcome/v-7。你还可以在 https://livebook.manning.com/#!/discussion 上了解有关 Manning 论坛和行为规则的更多信息。

曼宁对我们的读者的承诺是提供一个场所，使个人读者之间以及读者与作者之间可以进行有意义的对话。这不是对作者参与的任何特定数量的承诺，他对论坛的贡献仍然是自愿的（并且是无偿的）。我们建议你尝试向作者提出一些具有挑战性的问题，以免他的兴趣偏离！只要这本书还在印刷，就可以从出版商的网站上访问论坛和以前讨论的档案。

**其他在线资源**
有关 API 设计主题的进一步阅读，请参阅 https://aip.dev，其中详细介绍了许多类似的主题。

## 关于作者
J J Geewax 是 Google 的一名软件工程师，专注于实时支付系统、云基础设施和 API 设计。他还是 Google Cloud Platform in Action 的作者和 AIP.dev 的联合创始人，AIP.dev 是 Google 发起的 API 设计标准的全行业合作。他与妻子 Ka-el 和儿子 Luca 住在新加坡。

### 关于封面插图

API Design Patterns 封面上的数字标题为 Marchand d’Estampes à Vienne，或"维也纳的印刷商"。该插图取自 Jacques Grasset de Saint-Sauveur（1757-1810 年）的一系列来自不同国家的礼服，题为 Costumes de Différents Pays，于 1797 年在法国出版。每幅插图均由手工精心绘制和着色。 Grasset de Saint-Sauveur 丰富多样的系列让我们生动地想起了 200 年前世界城镇和地区的文化差异。人们彼此隔离，讲不同的方言和语言。无论是在街上还是在乡下，只要通过着装，就可以很容易地识别出他们住在哪里以及他们的职业或生活岗位。

从那时起，我们的着装方式发生了变化，当时如此丰富的地区多样性已经消失。现在很难区分不同大陆的居民，更不用说不同的城镇、地区或国家了。也许我们已经用文化多样性换取了更加多样化的个人生活——当然，换取了更加多样化和快节奏的技术生活。

在很难区分一本计算机书籍和另一本计算机书籍的时代，曼宁以基于两个世纪前丰富多样的地区生活的书籍封面来庆祝计算机业务的创造性和主动性，由 Grasset de Saint-索沃尔的照片。
