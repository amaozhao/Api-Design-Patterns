本章涵盖neir

- 如何隐式管理多对多关系
- 隐式关联而非显式关联的优缺点
- 如何使用自定义方法将资源关联在一起
- 处理相关资源的数据完整性问题

在本章中，我们将探索一种用于建模多对多关系的替代模式，该模式依赖于自定义添加和删除方法来关联（和取消关联）两个资源。 这种模式允许消费者管理多对多关系，而无需引入第三个关联资源作为必要要求。

## 15.1 动机
正如我们在第 14 章中了解到的，有时我们需要跟踪资源之间的关系，有时这些关系可能很复杂。特别是，我们经常必须处理两个资源可以同时拥有多个资源的情况，称为多对多关系。

虽然关联资源模式提供了一种非常灵活和有用的方法来建模这种类型的关系，但如果我们能忍受一些限制，是否有一种更简单的方法可以做到这一点似乎值得一问。换句话说，考虑到一些限制，我们可以让 API 更简单、更直观吗？如果是这样，具体的限制是什么？该模式探索了一种更简单的关联资源模式替代方案。

## 15.2 概述

正如您可能猜到的那样，肯定有更简单的方法来表示和操作 API 中的多对多关系，但它们有一些限制。在这个特定的模式中，我们将研究一种隐藏代表这些关系的单个资源的方法，并使用自定义方法来创建和删除关联。让我们首先总结方法，然后探索依赖这种设计模式时出现的具体限制。

在最基本的层面上，我们通过对消费者完全隐藏关联资源来简化 API，而是使用添加和删除自定义方法来管理关系。这些方法充当创建和删除相关两个资源之间关联的快捷方式，并隐藏有关该关系的所有详细信息，除了它存在（或不存在）的事实。在用户可以是多个组（以及显然包含多个用户的组）成员的经典示例中，这意味着我们可以简单地使用这些方法来表示用户加入（添加）或离开（删除）给定的组。

要采用这种模式，让我们看一下我们需要考虑的一些限制。首先，因为我们只存储两个资源关联的简单事实，我们将无法存储关于关系本身的任何元数据。这意味着，例如，如果我们使用此模式将用户作为群组成员进行管理，我们将无法存储有关成员资格的详细信息，例如用户加入群组的日期或用户可能在给定群组中扮演的任何特定角色.

接下来，由于我们将使用自定义方法来添加和删除资源之间的关联，我们必须将其中一个资源视为管理资源——有点像一个是另一个的父级。更具体地说，我们必须选择是将用户添加到组还是将组添加到用户。如果是前者，则用户资源是被传递的资源，而组资源是管理这种关系的资源。如果是后者，则用户正在管理关系，而组则被传递。考虑到实际代码（在这种情况下，在面向对象的编程风格中），管理资源是将添加和删除方法附加到它的资源。

清单 15.1 选择管理资源时两种选择的代码片段

```typescript
group.addUser(userId);    // ❶
user.addGroup(groupId);   // ❷
```

❶ 当一个组管理关系时，我们将用户添加到给定的组。
❷ 当用户管理关系时，我们向给定用户添加组。

有时管理资源的选择是显而易见的，但有时它可能更微妙，两种选择都有意义。在某些情况下，作为管理资源，两者都不是很直观，但在一天结束时，使用这种模式需要我们选择一个管理资源。假设我们可以忍受这两个限制，让我们看看这个特定模式必须如何工作的细节。

## 15.3 实现
一旦我们确定了管理资源，我们就可以定义添加和删除自定义方法。方法的全名应遵循 Add<Managing-Resource><Associated-Resource> 的形式（对于 remove 也是如此）。例如，如果我们有可以从组中添加和删除的用户，则用户将是关联资源和管理资源的组。这意味着方法名称将是 AddGroupUser 和 RemoveGroupUser。

这些方法应该接受包含父资源（在本例中为管理资源）和正在添加或删除的资源的标识符的请求。请注意，我们仅使用标识符而不是完整的资源。这是因为如果让消费者相信他们有能力关联两个资源并同时更新其中一个资源，那么其他信息将是无关紧要的并且可能会产生误导。表 15.1 中显示了 add 和 remove 方法及其 HTTP 等效项的摘要。

图 15.1 添加和删除方法摘要

| 行动                | 方法                                                         | HTTP 等价物                                           |
| ------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| 将用户 1 添加到组 1 | AddGroupUser({<br/>  parent: "groups/1",<br/>  userId: "users/1"<br/>}); | POST /groups/1/users:add<br/>{ userId: "users/1" }    |
| 从组 1 中删除用户 1 | RemoveGroupUser({<br/>  parent: "groups/1",<br/>  userId: "users/1"<<br/>}); | POST /groups/1/users:remove<br/>{ userId: "users/1" } |

### 15.3.1 列出相关资源
为了列出各种关联，我们将依赖定制的列表标准方法，这些方法看起来就像我们在关联资源方法中讨论的别名方法。这些方法只是简单地列出各种相关资源，提供对结果的分页和过滤。由于我们有两种查看关系的方法（例如，我们可能想查看哪些用户是给定组的成员以及给定用户属于哪些组），因此我们需要两种不同的方法的场景。

这些方法遵循与 add 和 remove 方法类似的命名约定，两种资源都在方法的名称中。使用我们的用户和组示例，我们提供了两种不同的方法来列出给定特定条件的各种用户和组：ListGroupUsers 提供属于给定组的用户列表，ListUserGroups 提供给定用户所属的组列表.就像其他自定义方法一样，它们遵循类似的 HTTP 映射命名约定，但依赖于隐式子集合，总结在表 15.2 中。

图 15.2 List 方法汇总

| 行为                    | 行动                                             | HTTP 等价物         |
| ----------------------- | ------------------------------------------------ | ------------------- |
| 组 1 中有哪些用户？     | ListGroupUsers({<br/>  parent: "groups/1"<br/>}) | GET /groups/1/users |
| 用户 1 是哪些组的成员？ | ListUserGroups({<br/>  parent: "users/1"<br/>}); | GET /users/1/groups |

### 15.3.2 数据完整性
当我们遇到重复数据的问题时，会出现一个常见问题。例如，如果我们尝试将同一用户添加到组中两次会怎样？另一方面，如果我们试图从他们当前不是成员的组中删除用户怎么办？

正如我们在第 7 章中看到的，这些情况下的行为将非常类似于删除一个不存在的资源并创建一个重复的（因此是冲突的）资源。这意味着如果我们尝试将用户添加到同一个组两次，我们的 API 应该响应冲突错误（例如，409 冲突），如果我们尝试从不存在的组中删除用户，我们应该返回表示失败假设的错误（例如，412 Precondition Failed）以表示我们无法执行请求的操作。

这意味着如果消费者关心的只是确保用户是（或不是）给定组的成员，他们可以简单地将这些错误情况视为他们的工作已经完成。换句话说，如果我们只想确定 Jimmy 是组 2 的成员，成功的结果或冲突错误都是有效的结果，因为两者都表示 Jimmy 当前是我们预期的组的成员。响应代码的差异只是表明我们是否负责将添加到组中，但要么表明用户现在是该组的成员。

### 15.3.3 API 最终定义

使用相同的用户和组示例实现的这种模式的完整示例如清单 15.2 所示。如您所见，这比依赖关联资源更短更简单；然而，我们缺乏存储关于属于组的用户关系的元数据的能力。

清单 15.2 使用添加/删除模式的最终 API 定义

```typescript
abstract class GroupApi {
  static version = "v1";
  static title = "Group API";
 
  @get("{id=users/*}")
  GetUser(req: GetUserRequest): User;
 
  // ...                                                // ❶
 
  @get("{id=groups/*}")
  GetGroup(req: GetGroupRequest): Group;
 
  // ...                                                // ❶    
 
  @post("{parent=groups/*}/users:add")
  AddGroupUser(req: AddGroupUserRequest): void;         // ❷
 
  @post("{parent=group/*}/users:remove")
  RemoveGroupUser(req: RemoveGroupUserRequest): void;   // ❷
 
  @get("{parent=groups/*}/users")
  ListGroupUsers(req: ListGroupUsersRequest):           // ❸
    ListGroupUsersResponse;
 
  @get("{parent=users/*}/groups")
  ListUserGroups(req: ListUserGroupsRequest):           // ❹
    ListUserGroupsResponse;
}
 
interface Group {
  id: string;
  userCount: number;
 
  // ...                                                // ❺
 
}
 
interface User {
  id: string;
  emailAddress: string;
}
 
interface ListUserGroupsRequest {
  parent: string;
  maxPageSize?: number;
  pageToken?: string;
  filter?: string;
}
 
interface ListUserGroupsResponse {
  results: Group[];
  nextPageToken: string;
}
 
interface ListGroupUsersRequest {
  parent: string;
  maxPageSize?: number;
  pageToken?: string;
  filter?: string
}
 
interface ListGroupUsersResponse {
  results: User[];
  nextPageToken: string;
}
 
interface AddGroupUserRequest { 
  parent: string;
  userId: string;
}
 
interface RemoveGroupUserRequest {
  parent: string;
  userId: string;
}
```

❶ 为简洁起见，我们将省略用户和组资源的所有其他标准方法。
❷ 我们使用 AddGroupUser 和 RemoveGroupUser 来操纵哪些用户与哪些组相关联。
❸ 要查看给定组中的用户，我们使用隐式子集合映射到 ListGroupUsers 方法。
❹ 要查看用户属于哪些组，我们使用相同的想法并创建一个 ListUserGroups 方法。
❺ 请注意，我们不会在此处内联用户，因为列表可能很长。要查看用户列表，我们改为使用 ListGroupUsers。

## 15.4 权衡

正如我们在本章开头所指出的，该模式的主要目标是提供管理多对多关系的能力，而无需承担完整关联资源的复杂性。为了换取这种简化，我们以功能限制的形式进行了一些权衡。

### 15.4.1 非互惠关系

与关联资源不同，使用 add 和 remove 自定义方法要求我们选择其中一个资源作为管理资源，另一个作为管理资源。换句话说，我们需要决定将哪个资源添加到另一个（和从另一个）添加（和删除）。在许多情况下，这种非互惠性既方便又明显，但在其他时候，这似乎违反直觉。

### 15.4.2 关系元数据

通过使用自定义添加和删除方法而不是关联资源，我们放弃了存储有关关系本身的元数据的能力。这意味着除了关系的存在（或不存在）之外，我们将无法存储任何信息。换句话说，我们无法跟踪关系的创建时间或任何特定于关系的内容，而必须将其放在其他地方。

## 15.5 练习
1. 您何时会选择使用自定义添加和删除方法而不是关联资源来建模两个资源之间的多对多关系？
2. 将 Recipe 资源与 Ingredient 资源关联时，哪个是管理资源，哪个是关联资源？
3. 将调用什么方法来列出构成特定配方的成分资源？
4. 当使用自定义添加方法添加重复资源时，结果应该是什么？

## 总结
- 对于关联资源太重的场景（例如，不需要任何额外的面向关系的元数据），使用 add 和 remove 自定义方法可以是管理多对多关系的更简单的方法。
- 添加和删除自定义方法允许在与管理资源的某种关联中添加或删除关联资源（即下级）。
- 可以使用元资源上的标准列表方法来列出相关资源。