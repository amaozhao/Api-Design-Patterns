本章涵盖内容

- 如何确定哪些失败的 API 请求可以安全重试
- 用于重试计时的高级指数退避策略
- 如何避免踩踏牛群
- API 可以为客户端指定重试时间的方式

当 Web API 发生错误时，其中一些是由于客户端错误造成的，而另一些则是由于客户端无法控制的问题。通常，第二组错误的最佳解决方案是稍后重试相同的请求，希望得到不同的结果。在此模式中，我们将探索一种机制，通过该机制，客户端可以在重试之前因 API 服务器错误而失败的请求的方式和时间方面有明确的方向。

## 29.1 动机
某些请求会失败是 Web API 不可避免的事实——希望不是大多数，但仍然有一些。许多这些失败的请求将是由于客户端错误，例如无效的请求消息，而其他的可能是由于 API 服务器上强制执行的先决条件和约束失败。所有这些类型的错误都有一个重要的属性：问题在于请求本身违反了某些约束或违反了 API 的业务逻辑。换句话说，如果我们再次重放相同的无效请求，我们应该得到相同的错误响应。毕竟，业务逻辑通常不会随时更改。

另一类错误则完全不同。有时，请求会导致完全暂时的错误响应。这种类型的错误与请求本身完全无关，而是 API 内部某些问题的结果。可能是 API 服务器过载，无法处理传入的请求，或者系统或必要的子组件正在计划停机并且在处理请求时不可用。不管问题如何，都有一个明确而明显的方法来解决这个问题：重试请求。

关键是错误响应并不是由发出的特定请求引起的。相反，响应是由于与请求相关的事情，而且更有可能与请求无关。这意味着，如果我们在未来的某个时间点再次尝试相同的请求，那么重试很有可能会成功（或者，至少，会导致不同的错误）。

那么最大的问题就变成了我们如何准确地确定应该重试的请求和不应该重试的请求之间的区别。通常，对 HTTP 错误进行编号以传达出了什么问题，某些错误比其他错误更有可能被重试。例如: 400 级错误（例如: 400 Bad Request、403 Forbidden、404 Not Found 等）可能是特定请求的问题，而 500 级错误（例如: 500 Internal Server Error 或 503 Service Unavailable）则是更可能代表内部服务的问题。在这两个类别中，500 级错误更可能是可重试的，但这更多是指导方针而不是实际规则，因此这当然需要更多讨论。此外，虽然这些错误代码可能暗示是否可以重试请求，但它们并没有真正说明客户端何时应该重试失败的请求，让客户端猜测在再次尝试相同请求之前要等待多长时间。

在此模式中，我们将探讨 API 服务如何定义重试策略，以确定哪些请求有资格重试，以及确定重试前等待多长时间的计时算法。我们还将介绍 API 服务如何在服务知道一些附加信息的情况下通知客户端准确的重试时间。

## 29.2 概述
这种模式的目标很简单：响应尽可能多的请求，同时尽可能少地重试。要做到这一点，我们需要解决两个问题。首先，我们必须为客户端提供一个算法，以尽量减少整个系统重试的请求数量。其次，如果 API 服务知道一些客户端不知道的信息，并且该信息将导致可以成功重试请求的特定时间，则该服务应该具有一种机制来向客户端提供何时重试请求的明确指令要求。让我们从确定重试请求之间的时间延迟的算法开始。

### 29.2.1 客户端重试时间
当我们遇到可重试的故障时，我们几乎肯定应该尝试再次发送相同的请求，希望该服务已经可用。但我们应该立即这样做吗？还是我们应该等一会儿？如果我们应该等，那么我们应该等多久？

事实证明，这是一个非常古老的问题，当我们需要一种算法来知道何时应该在潜在拥塞的网络上重试发送 TCP 数据包时，可以追溯到互联网的开始。这特别棘手，因为我们不知道发送请求后发生了什么，让我们简单地猜测请求何时更有可能在另一端成功处理。基于这些约束，针对此问题最有效、经过实战检验的算法是指数退避。

指数回退的想法非常简单。对于第一次重试尝试，我们可能会在再次发出请求之前等待一秒钟。之后，对于每个后续的失败响应，我们将之前等待的时间加倍。如果请求第二次失败，我们会等待两秒钟，然后再试一次。如果该请求失败，我们等待四秒钟，然后再试一次。这将继续加倍（8、16、32 秒）直到时间结束或直到我们决定放弃。我们将为该算法引入一些额外的部分，但核心概念将保持不变。

正如我们所指出的，当另一侧的系统是一个完整的黑盒时，该算法非常有用。换句话说，如果我们对系统一无所知，指数回退效果很好。但是，我们的 Web API 就是这种情况吗？事实上，情况并非如此，正如我们将在下一节中看到的，对于独特的场景子集，实际上有更好的解决方案。

### 29.2.2 服务器指定的重试时间
虽然指数回退仍然是一种合理的算法，但事实证明，在某些情况下，有更好的选择可用。例如: 考虑一个请求失败的场景，因为 API 服务说这个请求每分钟只能执行一次。在这种情况下，服务器实际上知道在重试请求之前要等待多长时间（在这种情况下，大约 60 秒）。

通常，只要服务器可以提供有关何时应重试请求的权威指导，就应将此信息传达回客户端。毕竟，即使是部分知情的猜测也比盲目猜测要好。虽然这些类型的场景并不常见，但它们肯定不是罕见到可以完全无视。

我们将依赖专门为解决这种情况而设计的参数。此参数（如果存在）指示客户端忽略他们通常使用的指数退避算法，而是仅根据提供的值重试请求，以确定何时重试。通过这样做，我们可以在大多数情况下为一些稍微更明智的猜测和在极少数情况下的绝对确定性覆盖盲目猜测。

## 29.3 实现
正如我们在上一节中了解到的，这种模式在大多数情况下依赖于指数退避，在其他情况下依赖于特殊字段，其中服务器可以指示客户端在重试请求之前确切地等待多长时间。然而，在我们进入这些主题的细节之前，房间里有一些大象需要讨论。我们如何确定是否应该重试给定的请求？

### 29.3.1 重试资格
假设所有错误都可以重试可能很诱人，但不幸的是，这是一个危险的假设。最大的担忧是这可能会导致一些意想不到的后果，例如重复结果（例如: 两次创建相同的资源）。我们如何知道哪些类型的请求可以重试，哪些不能？

一般而言，错误响应分为三类：绝对无法重试的响应、可能可以重试但应仔细查看的响应以及可能没有任何问题的重试响应。另外，能否重试还取决于API方法本身，尤其是是否幂等和安全。在本节中，我们将查看这些类别并总结属于每个类别的 HTTP 错误代码。

#### 一般可重审
不幸的是，被认为可能可重试的错误代码列表相对较短，总结在表 29.1 中。

表 29.1 通常可重试的响应代码示例

| Code | Name       | Description                              |
| ---- | ---------- | ---------------------------------------- |
| 408  | 请求超时   | 客户端生成请求的速度不够快。             |
| 421  | 错误的请求 | 请求被发送到无法处理它的服务器。         |
| 425  | 太早了     | 服务器不想尝试处理可能被重放的请求。     |
| 429  | 请求过多   | 客户端在给定的时间段内发送了过多的请求。 |
| 503  | 暂停服务   | 服务器无法处理请求，因为它过载了。       |

在代码 408、421、425、429 和 503 的情况下，服务器实际上甚至从未开始处理这些请求。 我们可以得出的结论是，重试收到这些错误响应的请求几乎肯定是可以接受的。

#### 绝对不可重试
通常，如果服务器接收并处理请求，但确定该请求以某种基本方式无效，则通常不可重试。 例如: 如果我们尝试检索资源并获得 403 Forbidden 错误，则重试请求不会导致不同的结果，除非 API 中有其他更改（例如权限调整）。 这些类型的错误（其中一些在表 29.2 中显示）很容易发现，因为它们是关于请求本身的错误或表明违反内在规则的服务器错误。

表 29.2 绝对不可重试的响应代码示例

| Code | Name         | Description                  |
| ---- | ------------ | ---------------------------- |
| 403  | 禁止的       | 请求很好，但服务器拒绝处理它 |
| 405  | 不允许的方法 | 指定的方法是不允许的         |
| 412  | 先决条件失败 | 服务器不满足请求的条件       |
| 501  | 未实现       | 服务器无法识别或处理请求     |

一般来说，所有这些响应代码都表明这种情况是永久性的，因此将来重试请求不会导致不同的响应。 （显然，这假设系统中没有其他任何变化。）

#### 可能可重试
最棘手的类别是可以接受重试请求的错误代码集，但这将取决于有关请求和 API 方法的更多详细信息。 例如: 504 Gateway Timeout 错误表示 API 请求被传递到下游服务器并且该服务器从未回复。 因此，我们不确定下游服务器是否真的收到并开始处理请求。 基于这种不确定性，我们只能在确定重复尝试不会导致任何问题的情况下重试请求。 表 29.3 中显示了属于此类别的请求示例。

表 29.3 可重试的响应代码示例

| Code | Name           | Description                          |
| ---- | -------------- | ------------------------------------ |
| 500  | 内部服务器错误 | 服务器发生意外故障                   |
| 502  | 错误的网关     | 请求被传递到发送无效响应的下游服务器 |
| 504  | 网关超时       | 请求被传递到一个从未回复的下游服务器 |

与往常一样，确保我们确实可以重试请求的最佳机制是依赖请求标识符作为允许服务器删除重复请求并避免不需要的行为的一种方式，如第 26 章所述。

现在我们已经了解了各种请求以及它们是否可重试（以及在什么情况下），让我们切换主题并开始查看我们认为可以接受重试请求的情况。 特别是，让我们看看在重试请求之前决定等待多长时间的方式。

### 29.3.2 指数退避
正如我们之前了解到的，指数退避是一种算法，通过该算法，请求之间的延迟呈指数增长，每次请求返回错误结果时都会加倍。 也许理解这一点的最好方法是查看一些代码。

清单 29.1 演示指数回退重试的示例

```typescript
async function getChatRoomWithRetries(id: string): Promise<ChatRoom> {
  return new Promise<ChatRoom>(async (resolve, reject) => {
    let delayMs = 1000;                                      // ❶
    while (true) {
      try {
        return resolve(GetChatRoom({ id }));                 // ❷
      } catch (e) {
        await new Promise((resolve) => {                     // ❸
          return setTimeout(resolve, delayMs);
        });
        delayMs *= 2;                                        // ❹
      }
    }
  });
}
```

❶ 我们将初始延迟定义为 1 秒（1,000 毫秒）
❷ 首先，尝试检索资源并解决承诺。
❸ 如果请求失败，则等待一段固定的时间，由延迟定义。
❹ 最后，下次我们需要等待的时间加倍。
虽然这个实现是一个很好的起点，但它可以使用一些改进。让我们先看看一些最大值。

#### 最大延迟和重试

正如我们之前提到的，指数退避通常会继续重试请求，直到时间结束或请求成功。尽管我们可能会欣赏算法的持久性，但这通常不是一个好策略，因为这意味着完成请求所需的时间没有限制。

为了解决这个问题，我们可以添加一些限制。首先，我们可以限制我们想要尝试的重试次数。然后我们可以为重试请求之间等待的最长时间添加一个限制。

清单 29.2 添加对最大延迟和重试计数的支持

```typescript
async function getChatRoomWithRetries(
    id: string, maxDelayMs = 32000, maxRetries = 10): Promise<ChatRoom> {
  return new Promise<ChatRoom>(async (resolve, reject) => {
    let retryCount = 0;                                      // ❶
    let delayMs = 1000;
    while (true) {
      try {
        return resolve(GetChatRoom({ id }));
      } catch (e) {
        if (retryCount++ > maxRetries) return reject(e);     // ❷
        await new Promise((resolve) => {
          return setTimeout(resolve, delayMs);
        });
        delayMs *= 2;
        if (delayMs > maxDelayMs) delayMs = maxDelayMs;      // ❸
      }
    }
  });
}
```

❶ 我们通过增加值并拒绝超过允许的最大值来跟踪重试（循环迭代）的次数。
❷ 我们通过增加值并拒绝超过允许的最大值来跟踪重试（循环迭代）的次数。
❸ 如果新的延迟时间大于最大值，我们将其更改为最大值。
有了这些新的限制，我们有办法确保该功能最终会失败，有效地说，"我们试了又试，但没有得到成功的响应。"既然已经涵盖了这一点，那么还有一个主题要解决：踩踏牛群。

#### 踩踏牛群
踩踏牛群并不是指在平原上奔跑的动物。在技术上，踩踏牛群是指一群远程客户端同时发出相同的请求，从而使接收端的系统过载的情况。简而言之，系统可能能够单独处理每个请求，但肯定不是同时处理所有请求，因为大量并发使系统不堪重负。但这与指数退避有什么关系？

为了理解这种联系，让我们考虑一下我们可能有 100 个不同的客户端同时发送请求的情况——可以说是一群群居动物。当这些客户端中的每一个看到他们的请求返回错误时，他们将立即开始重试，希望后续请求能够成功。然而，问题在于它们都将根据相同的指数退避算法来进行。结果是这 100 个请求中的每一个都将继续同时到达服务器，只是每个踩踏之间的间隙更大。换句话说，因为客户端碰巧遇到了意外同步的情况，请求会不断地相互干扰，直到它们都没有成功。从某种意义上说，算法的确定性导致了它的垮台。

我们能做些什么呢？一个简单的解决方案是引入一个客户端与另一个客户端不同的东西，而不是完全遵循指数退避算法。为此，我们将依赖请求之间延迟时间中的随机抖动概念。换句话说，除了指数退避算法规定的时间延迟之外，我们所要做的就是添加一些随机的等待时间。

代码清单 29.3 添加抖动以避免请求成群结队

```typescript
async function getChatRoomWithRetries(
    id: string, maxDelayMs = 32000, maxRetries = 10): Promise<ChatRoom> {
  return new Promise<ChatRoom>(async (resolve, reject) => {
    let retryCount = 0;
    let delayMs = 1000;
    while (true) {
      try {
        return resolve(GetChatRoom({ id }));
      } catch (e) {
        if (retryCount++ > maxRetries) return reject(e);
        await new Promise((resolve) => {
          return setTimeout(resolve,       
            delayMs + (Math.random() * 1000));    // ❶
        });
        delayMs *= 2;
        if (delayMs > maxDelayMs) delayMs = maxDelayMs;
      }
    }
  });
}
```

❶ 增加多达 1,000 毫秒的抖动以避免踩踏牛群。
请注意，这里引入的随机抖动不是附加的。换句话说，它不包括在由回退算法连续加倍的延迟中。

现在我们已经了解了指数回退算法如何深入工作，让我们换个角度考虑一下 API 服务器可能知道客户端应该等待多长时间的场景。

### 29.3.3 之后重试
指数退避（具有第 29.3.1 节中的增强功能）是确定何时重试给定请求的绝佳选择，但我们对这种算法的偏好通常是基于这样的假设：我们基本上没有可以帮助我们的附加信息做任何更聪明的事情。然而，在某些情况下，我们知道情况并非如此。最常见的例子是由于速率限制导致的错误，客户端发送请求过于频繁，而我们可以控制何时允许下一个请求。换句话说，由于 API 服务器确切地知道这个服务施加的限制何时会被重置，它也处于一个独特的位置，它可以准确地说明什么时候应该重试请求，这样它就不会再违反速率限制规则.

指示客户应该跳过指数退避例程而只是按照指示做的最佳方法是什么？事实证明，在 HTTP 的语义和内容规范中，有一个仅针对此主题的 Internet 工程任务组 (IETF) 标准：[RFC-7231](https://tools.ietf.org/html/rfc7231)。此 RFC 指定了一个"Retry-After"HTTP 标头（第 7.1.3 节），它指示客户端"在发出后续请求之前应该等待多长时间"。简而言之，此 HTTP 标头是 API 服务器发送有关何时应重试请求的更具体指令的理想场所。

这就引出了下一个问题：我们如何在这个 HTTP 标头中格式化我们的延迟指令？

#### 格式
规范明确指出 Retry-After 标头可以包含日期值（例如: Fri, 31 Dec 1999 23:59:59 GMT）或重试之前延迟的秒数持续时间（例如: 120）。尽管规范（和大多数现代 HTTP 服务器）将支持这两种格式，但依赖持续时间而不是时间戳几乎总是更好的选择。

这样做的原因是时间是一件棘手的事情。如果我们依赖持续时间，它由服务器生成，然后通过网络发送回客户端。这意味着客户端最终等待的总持续时间略长于指定的持续时间。例如: 如果服务器在 Retry-After 标头中放置值 120，并且响应从服务器传回客户端需要 100 毫秒，那么客户端实际上总共会延迟 120.1 秒。

将此与涉及时钟同步的更可怕的场景进行比较。如果服务器通知客户端它应该重试请求的特定时间，则假定服务器和客户端都同意当前时间。这不仅会受到持续时间格式 (120) 中存在的相同类型的传输延迟的影响，而且如果客户端的时钟碰巧与服务器的时钟不同步，它可能会导致更大的时间差异。例如: 如果服务器认为现在是中午而客户端认为是下午 1:00，那么当服务器说"下午 1:00 之前不要重试"时，客户端实际上会立即重试，而不是预期的 60 分钟延迟服务器。

虽然所有这些似乎有点牵强，但多年来，时钟一直是许多系统的垮台。由于闰秒、时区复杂性和时钟同步问题，假设两个系统具有彼此一致的时钟很少是一个好主意（更糟糕的是，依赖这一事实来获得正确的行为）。如果可能，最安全的做法是始终依赖持续时间而不是特定的时间值。

现在我们已经明确了 Retry-After 标头中应该包含的值，我们可以看到我们能够轻松实现对此的支持。

清单 29.4 添加对指定重试延迟持续时间的支持

```typescript
async function getChatRoomWithRetries(
    id: string, maxDelayMs = 32000, maxRetries = 10): Promise<ChatRoom> {
  return new Promise<ChatRoom>(async (resolve, reject) => {
    let retryCount = 0;
    let delayMs = 1000;
    while (true) {
      try {
        return resolve(GetChatRoom({ id }));
      } catch (e) {
        if (retryCount++ > maxRetries) return reject(e);
        await new Promise((resolve) => {
          let actualDelayMs;
          if ('Retry-After' in e.response.headers) {            // ❶
            actualDelayMs = Number(
              e.response.headers['Retry-After']) * 1000;
          } else {
            actualDelayMs = delayMs + (Math.random() * 1000);   // ❷
          }
          return setTimeout(resolve, actualDelayMs);
        });
        delayMs *= 2;
        if (delayMs > maxDelayMs) delayMs = maxDelayMs;
      }
    }
  });
}
```

❶ 如果提供了 Retry-After 值，我们将其用作延迟持续时间。
❷ 否则，我们将退回到标准的指数退避算法。
### 29.3.4 最终 API 定义

将所有内容放在一起，清单 29.5 显示了一个示例，演示了客户端应该如何理想地检索资源，包括具有指数回退和速率限制意识的重试。

清单 29.5 最终 API 定义

```typescript
async function getChatRoomWithRetries(
    id: string, maxDelayMs = 32000, maxRetries = 10): Promise<ChatRoom> {
  return new Promise<ChatRoom>(async (resolve, reject) => {
    let retryCount = 0;
    let delayMs = 1000;
    while (true) {
      try {
        return resolve(GetChatRoom({ id }));
      } catch (e) {
        if (retryCount++ > maxRetries) return reject(e);
        await new Promise((resolve) => {
          let actualDelayMs;
          if ('Retry-After' in e.response.headers) {
            actualDelayMs = Number(
              e.response.headers['Retry-After']) * 1000;
          } else {
            actualDelayMs = delayMs + (Math.random() * 1000);
          }
          return setTimeout(resolve, actualDelayMs);
        });
        delayMs *= 2;
        if (delayMs > maxDelayMs) delayMs = maxDelayMs;
      }
    }
  });
}
```

## 29.4 权衡
这种设计模式的不幸之处在于它依赖于客户按照指示去做。这可能是遵循使用指数退避或在确切时间后重试的说明，但关键仍然是决定最终留给客户，我们无法控制他们。

这种模式的好处是我们真的不会因为依赖它而放弃任何东西。指数回退是一种通用标准，已使用多年，在世界范围内取得了巨大成功。我们只会在服务器有一些特殊信息时指定特定的重试时间，因此如果遵循说明，可以减少重试请求。换句话说，这种模式通常没有缺点。

## 29.5 练习
1. 为什么没有一个简单的规则来决定哪些失败的请求可以安全地重试？
2. 依赖指数回退的根本原因是什么？重试之间随机抖动的目的是什么？
3. 什么时候使用 Retry-After 标头有意义？

## 总结

- 以某种方式暂时或时间相关的错误（例如 HTTP 429 Too Many Requests）可能是可重试的，而那些与某些永久状态（例如 HTTP 403 Forbidden）相关的错误重试大多是不安全的。
- 每当代码自动重试请求时，它应该依赖某种形式的指数回退，并限制重试次数和请求之间的延迟。理想情况下，它还应该引入一些抖动以避免所有请求都根据相同的规则重试并因此总是同时到达的踩踏问题。
- 如果 API 服务知道重试请求何时可能成功，则它应该使用 Retry-After HTTP 标头指示这一点。