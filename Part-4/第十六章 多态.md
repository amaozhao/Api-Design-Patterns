本章涵盖内容

- 什么是多态
- 多态的好处以及何时在 API 中使用它
- 如何最好地构建多态资源
- 为什么在面向资源的 API 中应该避免多态方法

在构建软件系统时，多态性为对象提供了多种不同形式的能力，通常依赖于显式的对象继承。 在这个模式中，我们将探索如何将这个强大的工具从面向对象的编程世界转换为面向资源的 API 设计世界。 我们还将研究何时依赖多态资源而不是完全独立的资源的一些准则。

16.1 动机
在面向对象编程 (OOP) 中，多态是在不同的具体类型之间使用单个通用接口的思想，最大限度地减少我们需要了解的实现细节，以便与特定类型进行交互。 换句话说，如果我们有类 Triangle 和类 Square，它们可能都实现了一个公共的 countSides() 方法并通过扩展共享接口 Shape 来指定它。

清单 16.1 TypeScript 中的多态示例

```typescript
interface Shape {
  countSides(): number;             // ❶
}
 
class Triangle implements Shape {   // ❷
  countSides() { return 3; }
}
 
class Square implements Shape {     // ❷
  countSides() { return 4; }
}
```

❶ 接口声明了一个必须实现的函数。
❷ 两个不同的类实现了接口，因此实现了声明的方法。
由于我们有这个通用接口，我们可以编写只处理 Shape 接口的代码，这意味着我们不必关心具体的形状是三角形还是正方形（或其他形状），只要它实现了要求 由 Shape 接口指定。

清单 16.2 计算任意形状边数的多态方法

```typescript
function countSides(shape: Shape): number {    // ❶
  return shape.countSides();
}
```

❶ 我们不必指定三角形或正方形作为输入。我们可以只要求该类实现 Shape 接口。
这个想法在 OOP 中非常强大，导致代码更加简洁和模块化，因此我们可能希望在 Web API 中具有相同的功能才有意义。当我们试图弄清楚如何将这个概念从面向对象编程语言的世界准确地转换为 JSON 和 HTTP 的世界时，问题就出现了。毕竟，在面向资源的 Web API 中，countSides() 方法的等价物是什么？代表我们想要的东西的正确资源是什么？此模式的目标是说明一种安全、灵活且可持续的方式，将面向对象编程的最强大功能之一带入面向资源的 API 世界。

## 16.2 概述
在这个模式中，我们将探索多态资源的概念。这些资源采用通用接口（例如: Shape）的形式，带有明确的字段，指定资源的更详细类型（例如: 三角形或正方形）。虽然依赖此策略有很多好处，但最重要的是我们不必为每个特定实现复制标准方法。换句话说，我们可以使用单个 ListShapes 方法，而不是 ListTriangles 和 ListSquares。

虽然这个策略简化了多态行为（例如: 与通用资源交互的方法而不是特定实现），但它没有说明多态的数据存储方面。换句话说，正方形有边长，三角形有底和高，这意味着要真正代表这些不同形状的细节，我们实际上需要在资源上存储不同的字段。为了解决这个问题，我们最终必须使用一些服务器端验证，这样我们的通用接口是必要字段的超集，因此能够存储对应于所有各种子类型的字段。换句话说，Shape 资源可能有一种方法来存储半径（对于圆形）、底边和高度（对于三角形）以及长度（对于正方形），并根据类型规范验证这些值。

然而，与往常一样，细节是事情变得复杂的地方。例如: 如果 API 请求包含应用于错误类型资源的字段（例如: 类型为 square 的 Shape 的半径定义），我们该怎么办？这应该是一个错误，还是应该被忽略？在下一节中，我们将更详细地探讨所有这些是如何工作的。

## 16.3 实现
在许多编程语言中，多态性显然是一个非常强大的工具，因此多态性资源对于 Web API 来说同样非常有价值是理所当然的。为了充分利用这个概念，我们需要从行为层面和结构层面了解这些资源是如何工作的。但在我们这样做之前，我们首先需要了解什么时候依赖多态性是有意义的。

### 16.3.1 决定何时使用多态资源

通常在设计 API 时，我们会发现两个提议的资源之间存在共性，这让我们三思而后行，将它们视为两个独立的资源。例如: 在聊天 API 中，我们可能会考虑 TextMessage 资源以及 PhotoMessage、VideoMessage 或 AudioMessage 资源。它们中的每一个都有一些共同点（例如: 它们都代表通过聊天 API 发送的消息），但它们彼此之间都略有不同（在这种情况下，这就是消息的内容）。

如果我们在本地编程时遇到同样的情况，我们可能会考虑 Message 接口和实现该接口的其他几个类，目标是编写仅处理通用 Message 接口类型的值而不是特定实现的代码那个界面。但是这个相同的逻辑会延续到 Web API 吗？换句话说，我们是否应该使用相同的一般性参数来确定是否为每种消息类型使用单个 Message 资源而不是多个独立的资源？

虽然直觉可能是正确的，但逻辑并没有完全翻译。更具体地说，我们在使用本地编程语言时关注的是通用性和编写支持未来扩展和代码重用等功能的函数。在我们的 Web API 中，我们应该更多地关注我们打算如何使用各种标准方法，以及这些标准方法是否在所有这些资源上运行相同，或者对不同类型有一些行为差异。

例如: 某事物应该依赖多态资源（例如 Message）而不是独立资源（例如 VideoMessage）的一个很好的指标是考虑将所有不同类型一起列出是否有意义。换句话说，我们是要调用单个方法并在单个响应中检索所有资源类型，还是只需要按不同的子类型列出资源？在聊天 API 的情况下，答案非常明显：我们几乎肯定希望列出 ChatRoom 资源中的所有消息，而不管它们的类型。否则，我们将很难检索正确的消息列表，需要我们进行多次 API 调用（然后将结果按创建时间交错）以适当地显示聊天内容。

考虑一个不同的场景，其中一个 API 可能拥有 ChatRoom 资源以及广播组，其中中央机构可以向所有用户发送单向更新。虽然这个"广播"概念本质上类似于聊天室资源，因为它们都包含消息，但我们与它们交互的方式却大不相同。成员资格是不确定的，他们只能由 API 的管理员创建，消息只向一个方向发送，列表不胜枚举。因此，即使这个概念可能会被压缩到一个多态的 ChatRoom 资源中（具有特殊的广播类型），如果我们要创建一个单独的广播资源，访问模式更有可能更容易管理，虽然类似于聊天室，但根本不同并且独立处理。

现在我们对如何在独立资源和多态资源之间做出决定有了一些指示，让我们探索如何构建这些特殊资源。

### 16.3.2 多态结构
多态资源有一个重要的区分字段：类型。 由于多态资源本身类似于我们编程语言中的通用接口，我们需要一种明确的方式来传达这个通用接口的实例是一个特定的子类型。 例如: 对于我们的 Message 接口，我们需要一种方法来指定消息是视频消息、音频消息等。 但是这个类型字段应该是什么样的呢？

#### 定义类型字段

虽然依赖枚举可能很诱人，但请回想一下第 5 章，枚举往往会带来许多问题，并且有一套非常具体的使用标准。 相反，我们可以使用一个简单的字符串字段，并对可以存储在该字符串字段中的值进行一些验证。

清单 16.3 带有类型字段的多态资源示例

```typescript
interface Message {
  id: string;
  sender: string;
  type: 'text' | 'photo' | 'audio' | 'video';   // ❶
  // ...
}
```

❶ type 字段只是一个简单的字符串，用于存储允许的子类型。
由于这个字段是一个简单的字符串，我们现在可以像使用其他任何字段一样使用它。例如: 如果我们想列出所有消息但只列出照片，我们可以调用 ListMessages() 并将过滤器应用于类型字段，正如我们将在第 22 章中看到的那样。这也意味着创建一个新消息资源可以采用任何相关形式，并将适当的值传递给 CreateMessage() 调用。

尽管这就像任何其他领域一样，但我们确实有一个重要的问题需要解决：这个领域应该是永久性的还是可以在现有资源上进行更改？换句话说，我们能否将资源从一种类型（例如: 视频消息）转变为另一种类型（例如: 文本消息）？虽然从技术上讲，资源上没有任何直接阻止它按预期工作的东西，但通常不鼓励这样做。原因是，随着 API 变得越来越复杂，并且不同资源之间的关系越来越多，更改多态资源的类型最终可能会破坏现有资源所做的假设，而该假设恰好引用了多态资源。当我们改变类型并打破这样的假设时，通常会导致用户混淆和 API 本身的错误。因此，应尽可能避免这种情况。

这种多态资源数据的想法将我们引向了下一个问题：我们究竟如何存储消息的内容？毕竟，对于每种不同的消息类型，存储的内容都大不相同。

#### 数据结构

多态资源的主要好处是，根据定义，它能够采用多种不同的形式。虽然这通常源于资源的行为（例如: 当我们对不同类型的多态资源调用相同的 API 方法时会发生不同的事情），但这些资源具有完全相同的结构是非常罕见的。相反，几乎可以保证不同类型将需要存储不同的信息。

在形状示例中，我们需要为圆形存储半径，而为正方形存储长度。对于我们在聊天中的 Message 资源，短信只能存储文本内容；然而，照片消息需要存储某种图像，这显然是完全不同的。那么我们该怎么做呢？

处理这个问题的最简单方法（恰好是更严格的接口定义语言的首选方法）是让资源充当每个单独类型的所有字段的超集。换句话说，消息资源可能有一个字段用于存储文本内容，另一个用于存储照片内容，另一个用于视频内容，等等。

清单 16.4 为每个属性使用不同的字段存储数据

```typescript
interface Message {
  id: string;
  sender: string;
  type: 'text' | 'photo' | 'audio' | 'video';
  text?: string;                               // ❶
  photoUri?: string;
  videoUri?: string;
  audioUri?: string;
}
```

❶ 资源通过定义所有相关字段来充当超集。
有时这种类型的超集排列是必需的，但在许多接口定义语言（例如我们在本书中使用的 TypeScript 语言）中，我们实际上可以重用单个字段来表示这些字段中的每一个。 换句话说，我们可以有一个单独的内容字段，而不是一个用于 text、videoUri 等的字段，它根据类型字段具有不同的含义。

清单 16.5 单个字段存储多个字段的数据

```typescript
interface Message {
  id: string;
  sender: string;
  type: 'text' | 'photo' | 'audio' | 'video';
  content: string;                             // ❶
}
```

❶ 此字段现在表示文本内容或媒体 URI，但取决于消息资源的类型。
到目前为止，在此示例中，每种不同的内容类型都表示为一个简单的字符串，但如果还有更多内容呢？ 例如: 如果我们需要跟踪媒体内容类型（例如: 视频的编码格式）以及视频文件的位置怎么办？ 在这种情况下，我们可能会为媒体内容定义一个单独的接口，同时仍然为基于文本的内容使用简单的字符串值。

清单 16.6 根据消息类型具有不同类型的字段

```typescript
interface Message {
  id: string;
  sender: string;
  type: 'text' | 'photo' | 'audio' | 'video';
  content: string | Media;                     // ❶
}
 
interface Media {                              // ❷
  contentUri: string;
  contentType: string;
}
```

❶ 在这种情况下，内容可以呈现多种不同的类型。
❷ 我们可以将 Media 定义为对包含实际内容和内容类型（例如 video/mp4）的 URI 的引用。
在所有这些例子中，一般指导原则是我们应该尝试抽象到结构继续具有实际意义的程度。 在消息的情况下，我们在文本和媒体的一般概念之间进行抽象没有问题，检查资源的类型然后适当地解释内容字段仍然很有意义。

但是，对于不同类型的 Shape 资源，尽管大多数字段都是数字类型，但字段的名称实际上非常重要。 因此，我们可能有一个维度字段来保存各种维度，但有多种类型来存储每个形状的不同维度信息。

清单 16.7 为不同的形状存储不同的字段名称

```typescript
interface Shape {
  id: string;
  type: 'square' | 'circle' | 'triangle';
  dimension: SquareDimension | CircleDimension |
   ➥ TriangleDimension;                         // ❶
}
 
interface SquareDimension {
  length: number;                                // ❷
}
 
interface CircleDimension {
  radius: number;                                // ❷
}
 
interface TriangleDimension {
  base: number;                                  // ❷
  height: number;
}
```

❶ 维度字段存储定义不同形状的各种方法。
❷ 每个形状的维度都有不同数量的字段，每个字段都有不同的名称。
既然我们已经介绍了结构，那么花点时间考虑一下我们如何与该结构进行交互可能是有意义的。更重要的是，可以这么说，当我们试图改变规则时会发生什么？

#### 数据验证

正如我们在上一个主题中看到的，不同类型的多态资源可能存储不同的信息。此外，虽然有时可以使用完全相同的字段并根据类型对其进行不同的解释，但有时我们需要为需要存储的不同信息指定不同类型的不同字段。当创建或更新多态资源时提供无效数据时，这两种情况都会导致更多的复杂性。

换句话说，就像字段可能会根据资源的类型字段有不同的解释一样，这也意味着需要以不同的方式应用验证规则。例如: 如果我们依赖一个带有 content: 字符串字段的简单消息资源，如果类型是文本，这个字段可能存储任意文本内容，但如果类型是媒体类型，则它应该是一个 URI，例如照片。因此，如果有人指定将消息视为照片消息，那么当内容字段不是有效的 URI 时，我们返回错误至关重要。

其他结构的要求更为微妙。例如: 在我们的各种可用形状示例中，维度字段的每个接口都有一组不同的字段名称（尽管它们都具有相同的类型）。如果我们提供额外的字段以满足要求但数据没有意义，会发生什么？换句话说，如果我们通过调用 CreateShape({ type: 'square', dimension: { radius: 10, length: 10 } }) 创建一个 Shape 资源呢？显然一个正方形没有半径，所以这个额外的信息是完全没有用的。

虽然像使用格式不正确的 URI 那样抛出错误可能很诱人，但在这种情况下，更好的选择是验证我们确实需要的输入是否按预期提供，然后简单地丢弃其他任何内容，就像我们对 unknown 所做的那样创建或更新任何其他资源时的字段。

现在我们已经了解了如何处理多态资源上的数据，让我们探索这些特殊资源的行为差异。

### 16.3.3 多态行为

到目前为止，我们的讨论完全是关于多态资源的结构和设计，但我们很少讨论如何与这些资源交互。正如我们在 16.1 节中看到的，无论是在编程语言还是 Web API 中，多态的部分好处是我们可以对通用接口而不是特定实现进行操作，但是操作的结果会因那个具体的实现。以第 16.1 节中的 countSides() 函数为例，我们可以很容易地将其转换为 Web API。

清单 16.8 计算不同形状边数的 API 方法

```typescript
abstract class ShapeApi {
  @post("/{id=shapes/*}:countSides")  
  CountShapeSides(req: CountShapeSidesRequest): CountShapeSidesResponse;
}
 
interface CountShapeSidesRequest {
  id: string;
}
 
interface CountShapeSidesResponse {
  sides: number; 
}
```

在此示例中，你可以想象响应：正方形将返回 {sides:4}，而三角形将返回 {sides:3}，对于其他形状类型，依此类推。 简而言之，由于我们选择资源作为通用接口（例如: Shape 或 Message），我们定义的方法将一如既往地在资源上运行，并且行为的任何偏差都可以归咎于我们遇到的典型方法 期望来自对各种领域具有不同价值的资源。 简而言之，我们早期的设计选择导致了非常方便的结果，与资源上的任何其他标准或自定义方法没有太大区别。

但这确实提出了一个真正应该解决的重要问题：如果我们拥有单独的资源并希望单个 API 方法能够对各种资源类型进行操作，那该怎么办？ 在下一节中，我们将详细探讨这一点并解释为什么它通常是一个坏主意。

### 16.3.4 为什么不是多态方法？
到目前为止，我们几乎只讨论了可以采用多种形式的单一资源。 这导致 API 方法非常简单，因为它们的行为与任何其他资源完全一样； 然而，有一种完全不同类型的多态性我们甚至都没有提到：多态方法。

出于本节的目的，我们将多态方法定义为能够对多种不同资源类型进行操作的 API 方法。 为了看一个人为的例子，让我们想象一个 API 中的通用 DeleteResource() 方法，它能够删除 API 中的任何资源，而不管资源类型如何。 请特别注意映射到"*/*"的 HTTP URL，而不是像"chatRooms/*"这样的特定集合。

清单 16.9 多态方法支持不同资源类型的行为

```typescript
abstract class GenericApi {
  @delete("/{id=*/*}")               // ❶
  DeleteResource(req: DeleteResourceReqeuest): void;
}
 
interface DeleteResourceRequest {
  id: string;                        // ❷
}
```

❶ 这个 URL 映射对应于任何类型的资源。
❷ 该字段可以代表任何资源类型的标识符。
看到这个例子时，一种常见的下意识反应是："等等。这要简单得多。为什么我们不直接这样做，而不是为每个资源使用所有这些单独的标准删除方法？"有趣的是，在技术层面上，这实际上是可行的，因为这里的方法能够处理基本上任何资源的删除。换句话说，由于DeleteResourceRequest 接口中提供的标识符是任意字符串，我们可以传入任何有效的资源标识符，引用任何可能的资源类型，该资源将被删除。在某种程度上，这有点像在 TypeScript 中定义一个带有方法签名的函数，看起来像 function deleteResource(resource: any): void。然而，像这样的方法往往弊大于利。

重要的是要记住，仅仅因为两个 API 方法具有相同的名称、目标、请求格式或方法签名并不意味着它们是相同的。当我们假装这两种方法相同并将它们结合起来时，就像我们在这里所做的那样，我们将来很可能会遇到麻烦。

在这种多态标准删除方法的情况下，我们可以清楚地删除任何资源，但不能保证所有资源都应该以完全相同的方式删除。例如: 也许我们希望支持对特定资源而不是所有资源的软删除（第 25 章）或验证请求（第 27 章）。这超出了这个单一示例，并扩展到可能对多种资源类型进行操作的任何方法。

任何能够对许多不同类型的资源（或所有资源）进行操作的方法的含义是，这些资源类型彼此之间的行为如此相似，以至于它们应该使用一个共享的 API 方法与它们交互。然而，不知何故，同时，它们的表示方式非常不同，以至于它们应该是完全独立的资源类型。

另一个重要的含义是，所讨论的资源将始终并且永远在其行为上保持足够相似，并且多态方法的所需行为的任何更改都将适用于所有资源。换句话说，该方法的行为将始终针对所有资源类型而改变，而不是逐案改变。

在这两种情况下，我们都取得了相当大的飞跃。首先，我们是说资源在行为上是相同的，应该使用单一的 API 方法，但在表示上也完全不同，应该使用独立的资源定义。在第二个中，我们假设这种相同的行为是一个永久性的固定装置，这样所有资源都将在整个 API 中统一地改变它们的行为。

虽然确实有可能存在一种情况使这些影响变得合理，但现在或将来它们中的一个更有可能瓦解。而且由于我们没有水晶球来帮助预测 API 的未来，因此假设事情会发生变化并且会以自己独特的方式发生变化，而不是作为一个统一的群体发生变化，这要安全得多。基于此，支持多态 API 方法几乎从来都不是一个好主意。

不幸的是，这确实意味着更多的打字。另一方面，API 保持灵活和适应性，而不是脆弱和笨重。

#### 16.3.5 API 最终定义
在下面的示例中，我们可以看到如何为 Message 资源依赖面向资源的多态性，从而产生一组简化的 API 方法，并利用多态性对资源布局的好处。

清单 16.10 最终 API 定义

```typescript
abstract class ChatRoomApi {
  @post("/{parent=chatRooms/*}/messages")
  CreateMessage(req: CreateMessageRequest): Message;
}
 
interface CreateMessageRequest {
  parent: string;
  resource: Message;
}
 
interface Message {
  id: string;
  sender: string;
  type: 'text' | 'image' | 'audio' | 'video';
  content: string | Media
}
 
interface Media {
  uri: string;
  contentType: string;
}
```

## 16.4 权衡
API 中的多态性是一个非常强大的工具，但它也可能很复杂。虽然很多时候它可能非常适合（例如: 多种类型的消息资源的示例），但可能还有其他资源看起来相似但仍然存在一些根本差异。一个好的经验法则是考虑资源是否都是通用资源类型的真正特殊类型（就像 PhotoMessage 肯定是特定类型的 Message）。原因是依赖这种模式确实将资源锁定在特定的表示中，这种表示在将来很难（如果不是不可能的话）以不间断的方式解开。

最重要的是，出于前面讨论的原因，理想情况下，Web API 中的多态性应该关注多态资源而不是多态方法。虽然在某些情况下多态方法可能有用，但请仔细考虑资源的行为随着时间的推移开始偏离的可能性。这是因为这些类型的方法现在可能会带来便利和更少的输入，但这样做的代价是一副手铐，限制了 API 的未来灵活性。

## 16.5 练习

1. 假设你正在创建一个 API，该 API 依赖于 Web 浏览器的 URL 书签，该书签可以排列到集合或文件夹中。将这两个概念（文件夹和书签）放入单个多态资源是否有意义？为什么或者为什么不？
2. 为什么我们应该依靠字符串字段来存储多态资源类型而不是枚举之类的东西？
3. 为什么要忽略附加数据（例如: 为 square 类型的 Shape 资源提供半径）而不是因错误而拒绝？
4. 为什么要避免多态方法？为什么拥有一组多态的标准方法（例如: UpdateResource()）是个坏主意？

## 总结

- API 中的多态性允许资源采用不同的类型，以避免重复共享功能。
- 通常，当用户可以合理地期望将多种类型的资源一起列出（例如: 在聊天室中列出每条消息可能属于不同类型的消息）时，依赖多态性是有意义的。
- 多态资源的类型信息应该是一个字符串字段，但应该小心地更改（添加或删除）该字段的可能选择，以避免破坏
- 有的客户端代码。
- 验证不是为无效输入数据抛出错误，而是检查所需数据是否存在并忽略任何不相关的数据。
- 通常应避免使用多态方法，因为它们会阻止未来随着时间的推移行为发生偏差。