本章涵盖内容

- 什么是标识符
- 良好标识符的属性
- 好的标识符实际上是什么样的
- 如何实现一个制作标识符的系统
- 本指南如何与 UUID 配合使用

在本章中，我们将深入探讨资源标识符。 这包括它们是什么，什么是好的（和坏的），以及如何在你的 API 中使用它们。 我们还将深入研究当今使用的一些常见标识符格式(例如: 通用唯一标识符或 UUID；https://tools.ietf.org/html/rfc41220), 以及专门针对使用的新自定义格式 在 Web API 中。

## 6.1 什么是标识符？
首先，当我们谈论资源标识符时，我们到底是什么意思？简而言之，标识符为我们提供了一种在 API 中唯一寻址和讨论单个资源的方法。用更专业的术语来说，这些标识符是字节块（通常是字符串值或整数），我们可以将其用作指向资源集合中的一个资源的方式。几乎总是，这些标识符使 API 的用户能够执行某种类型的查找操作。换句话说，这些标识符用于在一些更大的资源集合中寻址单个资源。

事实证明，我们在日常生活中经常使用这样的标识符；然而，并非所有标识符都同样有用（甚至同样独特）。例如: 许多政府使用姓名和出生日期作为一个人的标识符，但在很多情况下，人们基于没有两个人共享姓名和出生日期的假设而混淆。至少在美国，更好的选择是社会安全号码（政府分配的九位数号码），用于在大多数金融交易（例如纳税或贷款）中唯一标识一个人，但这个数字有其自身的一系列缺点。例如: SSN 目前的总数限制为最多 10 亿人（九位数），因此随着美国人口多年来的增长，该国可能会用完数字来提供。

在 API 中为资源提供标识符显然很重要；然而，这些标识符究竟应该是什么样子还不太清楚。换句话说，我们不一定要说明哪些属性使某些标识符好而另一些标识符不好。在下一节中，我们将更详细地探讨这些。

## 6.2 什么是好的标识符？

由于我们需要在 API 中交互的几乎所有资源都需要标识符，因此很明显标识符很重要。而且由于我们作为 API 设计者来选择这些标识符的表示形式，这就留下了一个大问题：什么使标识符好？为了回答这个问题，我们需要探索标识符的许多不同属性以及我们需要在其中做出决定的各种选项。现在，我们将专注于属性本身，稍后会提出更具体的建议（在第 6.3 节中）。

### 6.2.1 使用方便

最简单的开始是最明显的地方之一：标识符应该在最常见的场景中易于使用。标识符最典型的场景可能是在 Web API 中查找单个资源（我们在 1.4 节中作为标准 get 方法学到的）。这意味着向服务器发送请求"请给我资源 <ID>"应该尽可能简单明了，同时尽量减少出错的机会。特别是，这必须考虑到标识符经常出现在 URI 中的事实。这意味着，例如: 在标识符中使用正斜杠 ("/") 或其他保留字符将有点棘手，因为它们在 URI 中具有特殊含义，应该避免使用。

### 6.2.2 独一无二

一个好的标识符的另一个明显要求可能是它必须是真正唯一的。换句话说，根据定义，标识符必须完全是一种类型，否则它无法真正完成其工作，即唯一标识 API 中的单个资源。这可能看起来有点过于简单化，但我们需要解决一些微妙之处，以了解真正独特的含义。其中之一是唯一性很少是绝对的，而是通常取决于考虑标识符的上下文或范围。例如: 在计算机公司的范围内，Apple 被认为是唯一标识符（计算机公司的范围内只有一个 Apple），但在所有公司的范围内，Apple 实际上并不是唯一的（还有 Apple Records、Apple Bank ， 等等。）。我们需要决定标识符是否需要在所有相同类型的资源、同一 API 中的所有资源或世界上的所有资源中都是唯一的。诚然，真正的全局唯一性在理论上是不可能的，但在给定足够大的密钥空间（标识符的可能选择）并且没有故意的坏人的情况下，在实践中应该是可行的。

### 6.2.3 永久性
接下来，更微妙的是，标识符一旦被分配就可能不应该改变。这主要是因为在标识符最终发生变化的情况下引入了潜在问题（因此需要做出进一步的决定）。例如: 想象一下 ```Book(id=1234, name="Becoming")``` 更改其标识符并变为 ```Book(id=5678, name="Becoming")``` 的情况。这本身可能不是什么大问题，但考虑到创建了一本新书：```Book(id=1234, name="Design Patterns")```。在这种情况下，这本新书重用了原始标识符 (1234)，这最终意味着根据你请求 Book 1234 的时间，你会得到不同的结果。

对于大多数情况，这可能不是什么大问题，但想象一下，用户可以指定他们最喜欢的书，并且有人选择书 1234 为他们最喜欢的书（```User (favoriteBook=1234, ...)```）。这留下了一个非常合理的问题：他们最喜欢的书是《成为》还是《设计模式》？在这个标识符不是永久性的世界中，要回答我们指的是哪本书的问题，我们还需要知道什么时候选择了最喜欢的书，或者更具体地说是什么时候检索到了书 1234。没有这些信息，就不清楚是什么书我们实际上在谈论。因此，最好的标识符不仅是永久的，而且是一次性的，永远的。换句话说，一旦 Book 1234 存在，即使在原始 Book 1234 被删除之后，你也不应该再次使用相同的标识符。

### 6.2.4 快速简便的生成

到目前为止，我们一直使用像"1234"这样的简单数字作为示例标识符，但这些不太可能是现实生活中的实际标识符。相反，这些标识符更有可能具有一些随机性元素，而不是依赖于递增的整数。由于这通常意味着在选择这些标识符时需要更多的计算，因此确保做出该选择不会花费太长时间是很重要的。

例如: 由于我们说所有标识符必须是永久的和永远一次性使用的，这意味着我们需要确定我们选择的任何 ID 都没有被使用过。我们可以通过保留所有资源的列表并随机选择 ID 直到找到以前没有使用过的 ID 来做到这一点，但这既不是最有效也不是最简单的选择。随着时间的推移，它也可能变得越来越慢，使其成为更糟糕的选择。无论我们选择什么选项，它都应该是快速和简单的，最重要的是，它具有可预测的性能特征。

### 6.2.5 不可预测

虽然在选择标识符时快速和容易（并且可以预测）很重要，但人们很难预测下一个标识符将是什么也很重要。最终这归结为安全性，并且可以通过足够大的密钥空间轻松解决，但是如果选择这些标识符的方法就像选择下一个可用数字一样简单，则可以更轻松地定位和利用潜在漏洞，例如错误配置的安全规则.

例如: 如果攻击者只是在随机分配的 256 位整数密钥空间中随机检查意外未受保护的资源，那么登陆甚至存在的资源的可能性很小，更不用说配置错误的资源了。另一方面，如果我们使用更可预测的方法，例如在相同的密钥空间（1、2、3、...）上计算整数，那么攻击者几乎可以保证找到存在的资源并且可以希望降落在一个被错误配置为向世界开放而不是被锁定的地方。

### 6.2.6 可读、可共享和可验证
其次，虽然我们作为工程师可能不愿意承认这一点，但我们在 API 中使用的标识符可能在某个时候需要通过电话进行通信、粘贴到文本消息中或通过其他一些非计算媒体共享。这意味着，例如: 我们不想混淆数字 1、小写 L、大写 I 或管道字符 (|)，因为将这些写在纸上可能会很棘手（尝试传达"l1Il|lI1I1lIl1I1l1lI"通过电话，即使在代码字体中也很棘手！）。简而言之，我们应该考虑到标识符将被人类解释和传达，因此重要的是它们在这方面没有不必要的困难。

除了容易沟通之外，一个好的标识符可以很容易地快速确定标识符本身是否被复制错误。换句话说，我们应该能够区分指向任何内容的有效标识符和永远不会指向任何内容的完全无效标识符之间的区别。提供这一点的一种简单方法是使用标识符的简单校验和段。这不是一个疯狂的想法，并且经常使用。例如: 用于书籍的标识符称为 [ISBN](https://en.wikipedia.org/wiki/International_Standard_Book_Number)，它们就是这样工作的，其中书籍 ISBN 的最后一位用作校验位以验证其他数字实际上是有意义的，并且没有被打错。

### 6.2.7 信息密集

最后，标识符将一直被使用，因此大小和空间效率将很重要。这意味着我们应该渴望将尽可能多的信息打包成尽可能短的值。这可能意味着选择密度更高的字符集，如 [Base64](https://tools.ietf.org/html/rfc4648) 而不是密度更低的字符集，如简单数字。在这个例子中，如果我们使用数字 ID，我们只能为每个字符存储总共 10 个选项，但如果我们使用 Base64 编码的文本，我们可以为每个字符存储 64 个选项。

优化信息密度将是与其他构成良好标识符的属性的平衡行为。例如: Base64 有许多可用的字符，但这些字符包括小写的"i"、大写的"I"和数字"1"，我们了解到在写下或阅读时可能会造成混淆。为了了解所有这些是如何结合在一起的，让我们看看如何为这些标识符选择格式的各种设计考虑因素。

## 6.3 好的标识符是什么样的？
现在我们对在一个好的标识符中寻找哪些属性有了一个不错的想法，我们可以尝试实现一个方案来定义资源标识符。首先，我们将介绍建议的实现，然后将其与第 6.2 节中描述的各种标准进行比较。

### 6.3.1 数据类型

在我们进入更多其他内容之前，我们需要首先确定用于存储这些标识符的数据类型。虽然有很多合理的选择，但到目前为止，字符串是最通用的，因此是推荐的选项。它们提供最高的信息密度（HTTP 上使用的每个字符的熵为 7 位），使用起来很熟悉，并在决定如何使它们易于共享、阅读和复制时提供了很大的回旋余地。

虽然还有其他几种选择，从常见的（例如: 正整数）到不那么常见的（原始未解释字节），但它们提供了由它们的类型强加的人为限制（例如: 整数被限制为每个 ASCII 字符 10 个选择，或HTTP 上每个 ASCII 字符约 3.3 位熵）或其他缺点（例如: 原始字节在许多编程语言中不方便使用）。

既然我们已经确定了字符串，我们就有了一组全新的问题要回答。首先，这些字符串的字符集是什么？我们可以使用任何有效的 Unicode 字符串吗？还是有限制？之后，我们必须决定是否允许所有字符。例如: 在 HTTP 中，正斜杠字符（"/"）通常用于表示分隔符，因此我们可能不希望在标识符中使用它。此外，正如我们之前了解到的，某些字符（如管道字符"|"）很容易与其他字符（如"I"、"1"或"l"）混淆。我们怎么办？让我们从查看字符集开始。

### 6.3.2 字符集
尽管我很想回忆和解释 Unicode 及其所有内部工作原理，但这不仅需要太长时间，而且我怀疑我对标准的了解仍然存在差距。因此，我将重点关注一些涉及字符集的简单示例，以阐明为什么此实现将依赖于 ASCII（美国信息交换标准代码）。

ASCII 非常简单：7 位数据代表 128 个不同的字符。这些数据通常被推入一个 8 位字节，当与当今的大多数 Web API 交互时，HTTP 请求会使用该字节。正如你可能猜到的，有超过 128 个不同的字符，而这正是 Unicode 规范旨在解决的问题。这很棒;然而，在实现最终向后兼容性的使命中，Unicode 实际上允许以多种方式来表示我们认为相同的文本块。例如: "á"可以表示为单个 Unicode 代码点 (U+00E1) 或"a"和重音字符代码点（U+0061 和 U+0301）的组合。虽然它们在我们的屏幕上（或纸上）看起来都像"á"，但当它们存储在数据库中时，它们看起来非常不同——这正是问题所在，因为计算机看不到视觉上的"á"字符；他们看到构成它的字节。

虽然肯定有办法解决这个问题（例如: 使用规范化形式 C 和其他 Unicode 魔法），但歧义导致的问题远远超过其价值（例如: 你现在必须指定如何处理提交的数据标准化形式 C 等）。因此，现代 Web API 最安全的选择是依赖 ASCII 作为唯一标识符。

现在我们已经确定了 ASCII，我们需要决定是否由于其他问题将其进一步限制为 128 个字符的子集。

### 6.3.3 标识符格式
如果我们可以使用 ASCII 提供的所有 128 个字符（甚至是 Unicode 标准可以表示的所有字符串），那就太好了，但我们需要考虑一个重要且理想的标识符属性，我们在第 6.2.6 节中讨论过：便于阅读、分享和复制。这意味着，很简单，我们需要避免 ASCII 中容易与其他字符混淆或可能混淆 HTTP 请求中的 URL 的字符。这将我们引向了一个非常有用的序列化格式：Crockford 的 [Base32](https://www.crockford.com/base32.html)。

Crockford 的 Base32 编码依赖于使用 32 个可用的 ASCII 字符，而不是全部 128 个。这包括 A 到 Z 和 0 到 9，但遗漏了许多特殊字符（如正斜杠）以及 I、L、O 和U. 虽然前三个由于潜在的混淆（I 和 l 可能与 1 混淆，O 可能与 0 混淆）而被排除在外，但第三个被排除在外是另一个有趣的原因：亵渎。事实证明，通过省略 U 字符，实际上不太可能在标识符中出现英语脏话。

话虽如此，你可能已经注意到其他令人困惑的事情：我们为什么要费心忽略 L？毕竟，大写形式不能与任何东西混淆；但是，它可能会以小写形式（与 1）混淆。原因是这种格式具有单一的规范形式，由大写字母（较少提及）和 0-9 组成，但在解码各种输入时更容易出错。在这种情况下，该算法不是简单地说 L 是一个无效字符，而是假设它被错误地（以小写形式）当成了数字 1 并以这种方式对待它。这种不区分大小写的情况更普遍（例如: a 被视为 A）并适用于其他可能混淆的字符，例如 O 和 o（将被视为 0）。换句话说，这种格式对错误非常友好，并且被设计为可以基于这些错误将继续发生的假设来做正确的事情。

最后，Crockford 的 Base32 编码将连字符视为可选，这意味着我们可以根据需要灵活地引入连字符以提高可读性。这意味着我们可以拥有 ID abcde-12345-ghjkm-67890，它在 Crockford 的 Base32 中将被规范地表示为 ABCDE12345GHJKM67890。

简而言之，Crockford 的 Base32 编码满足了 6.2 节中概述的大量标准：易于使用、易于实现唯一性、提供了相当高的信息密度（32 个选项或每个 ASCII 字符 5 位）、易于变得不可预测、最重要的是，由于其适应和灵活的解码过程，非常可读、可复制和可共享。现在我们还有几个问题需要解决。

### 6.3.4 校验和
第 6.2.6 节中列出的关键要求之一是能够区分丢失的标识符（例如: 从未创建或删除）和永远不可能存在的标识符，这意味着显然存在错误在标识符中。一种简单的方法是将某种形式的完整性检查作为标识符的一部分。这种完整性检查通常采用标识符末尾的一些固定数量的校验和字符的形式，该校验和字符源自标识符本身的其余内容。然后，在解析标识符时，我们可以简单地重新计算校验和字符并测试它们是否匹配。如果没有，则标识符的某些部分已损坏，并被视为无效。

Crockford 的 Base32 包含一个基于模计算的简单算法。简而言之，我们把这个值当作一个整数，除以37（大于32的最小素数），然后计算这个值的余数。然后我们使用单个 Base37 数字（规范包括 5 个额外的校验和数字字符）来表示余数。

### 6.3.5 资源类型
虽然我们主要关注标识符的唯一部分，但能够从标识符知道资源的类型也非常有价值。换句话说，被告知资源的 ID 为 ```abcde-12345-ghjkm-67890``` 并不是很有用，除非你还被告知所涉及的资源类型（以便你可以决定要调用的 RPC 或访问的 URL 来检索资源，例如）。对此的一种常见解决方案是在 ID 前面加上相关集合的名称，例如 ```books/abcde-12345-ghjkm-67890```。通过这样做，我们可以获取该标识符，了解它所谈论的资源类型，并用它做有用的事情。通过使用正斜杠作为分隔符，我们最终得到一个适合 HTTP 请求的完整标识符（例如: ```GET /books/abcde-12345-ghjkm-67890```）。还有很多其他可用的选项（例如: 使用冒号字符，产生类似 ```book:abcde-12345-ghjkm-67890``` 的 ID）；然而，鉴于与 HTTP 的友好关系以及在标准 URL 中的有用性，带有集合名称的正斜杠往往非常适合。

### 6.3.6 层次和唯一性范围

既然我们已经决定使用集合名称作为标识符的一部分（例如: ```books/1234``` 而不仅仅是 1234），这就引出了一个新问题：层次结构在标识符中是如何工作的？例如: 如果我们同时拥有 Book 资源和 Page 资源（页面属于书籍），我们是在标识符中表达这种层次关系还是将每个资源作为自己的顶级资源？换句话说，Page 资源是否有一个标识符，如 ```pages/5678```（顶级资源）或 ```books/1234/pages/5678```（表示标识符中的层次关系）？

答案是层级关系非常有用，应该在适当的时候使用，但是有一组特定的场景是有意义的（并且在许多情况下层级不是一个好的选择）。很多时候，API 设计者依赖层级关系作为两种资源之间关联的表达，而不是所有权，这可能会成为问题。例如: 我们可能会说，"Book 1 当前在 Shelf 1"，最终的资源标识符看起来像```shelf/1/books/1```。不幸的是，随着时间的推移，书籍往往会在书架之间移动，我们需要更改标识符以反映这种移动。而且，正如你可能猜到的，这与我们在第 6.2.3 节中定义的永久性要求背道而驰。

虽然制定"书籍永远不会在书架之间移动"的规则可能是完全合理的（在这种情况下，这个标识符将是完全合理的），但这种行为限制并不是真正必要的。相反，我们应该简单地认识到一本书在书架上的当前位置是书本身的可变属性，并将shelfId存储为Book资源的一个属性。

什么时候使用分层标识符才有意义？一般来说，当 API 代表一种资源对另一种资源的真正所有权时，它们应该只依赖于层次关系，特别是关注关系的级联特征。这意味着当我们想要级联删除（如果你删除父级，它会删除子级）或级联安全规则（在父级上设置安全规则，它们向下流向子级）之类的事情时，我们应该在其他资源下分层资源。显然，正如我们之前提到的，资源不应该能够从一个父级转移到另一个父级。例如: 虽然书籍可能会在书架之间移动，但页面通常不会在书籍之间移动。这意味着我们会将 Page 资源标识为 ```books/1/pages/2``` 而不仅仅是 ```pages/2```。

此外，在我们依赖分层标识符来表达所有权关系的情况下，重要的是要记住子资源（页面）只存在于其父资源（书）的上下文中。这意味着我们永远不能单独谈论第 2 页，因为这会引出一个显而易见的问题：哪本书的第 2 页？实际上，这意味着页面的标识符始终包含父资源的标识符。

这导致了一个稍微微妙的问题，但仍然非常重要：我们可以拥有多个 ID 为"2"的页面吗？例如: 我们可以同时拥有 ```books/1/pages/2``` 和 ```books/9/pages/2``` 吗？这个特定的例子应该有希望使这个答案明显是肯定的。毕竟，很多书都有第二页。由于父资源不同，标识符是两者在层次关系中的组合，而这两个标识符相似（因为它们都以"pages/2"结尾），所以这两个字符串完全不同，这两个页面属于到完全不同的书（在这个例子中，书 1 和书 9）。

现在我们已经了解了一个好的标识符可能是什么样子，让我们来看看创建和使用符合这些期望的标识符所涉及的一些较低级别的技术细节。

## 6.4 实现
到目前为止，我们已经探索了标识符的特征和一些细节，但还有很多更深层次的技术细节需要形式化，这是本节的重点。让我们先看看标识符的一些简单和基本的东西：它有多大。

### 6.4.1 长度

给定的标识符应该有多长？虽然我们可以简单地说它随时间变化（即，标识符的长度可能会随着创建的越多而增加），但对于使用可能将这些标识符存储在他们的数据库中的 API 的人来说，这会使事情变得相当复杂，所以它通常是一个为这些标识符的空间要求提供一些可预测性的好主意，并且只需为它们的长度选择一个固定的大小。

在这种情况下，我们有几种不同的选择，具体取决于我们的需求。首先解决最简单的选项，我们可能只需要在单个资源类型中唯一的标识符。换句话说，同时拥有 book 1 和 author 1 可能完全没问题，因为我们有不同的资源类型来区分这两个 1。在这种情况下，我们可能只需要大约 64 位的存储空间（类似于在 MySQL 等关系数据库中使用单个 64 位整数）。使用 Crockford 的 Base32，我们对每个 ASCII 字符总共有 32 个选择（或 5 位），这意味着我们可能会得到 12 个字符作为标识符（为我们的标识符提供 60 位）。当序列化（和反序列化）它时，我们将需要一个额外的字符作为校验和数字，这意味着总共 13 个字符，导致诸如书籍/AHM6A83HENMP~（或书籍/ahm6a83henmp或书籍/ahm6-a83h-enmp）之类的标识符使用小写和潜在的连字符作为可读性的分隔符）。

在其他一些情况下，我们可能需要全局唯一的标识符——不仅跨资源类型，甚至跨单个 API，而且跨所有资源。为了实现这一点，我们的目标应该是至少拥有与标准 UUID（通用唯一标识符）相同数量的可能标识符，这是一个由 32 个十六进制数字表示的 128 位 ID。由于这些位中的 6 位保留用于有关 ID 的元数据，因此剩下 122 位用于标识符值。使用 Crockford 的 Base32，我们需要大约 24 个字符，这将为我们提供 120 位标识符。将此与一个额外的校验和数字相结合，总共 25 个字符，导致标识符可能看起来像书籍/64s36d-1n6rv-kge9g-c5h66~（请记住，连字符是可选的，技术上可以放在任何地方，所有字母都是不区分大小写）。

正如我们稍后在讨论别名时将了解到的，我们可能想要引入一个前导"0"字符来区分标识符和别名，这将为我们的常规 ID 添加一个额外的字符。尽管如此，现在是时候讨论一个重要但微妙（迄今为止被假设）的问题：谁制作了 ID。

### 6.4.2 生成

我们已经讨论了很多关于标识符应该采用的格式和数据类型；然而，有一个假设是这些只是随机标识符，我们没有说明如何实际创建它们。让我们从一个重要的方面开始：起源。

#### 起源

在我们讨论如何生成这些标识符之前，我们应该首先讨论谁应该实际创建它们。总之，值得注意的是，允许 API 的用户选择自己的标识符是一件非常危险的事情，应该避免。

对于初学者来说，当这个名字在过去的某个时候被使用过时，这可能会导致沮丧和困惑。由于我们的永久性要求（第 6.2.3 节）意味着永远不能重用标识符（即使在被删除之后），想要重新创建资源的用户可能会因为在确定资源时收到有关 ID 冲突的错误消息而感到困惑具有该 ID 的不存在（现在可能不存在，但在过去的某个时候确实存在）。虽然这可以通过足够大的可用 ID 集来缓解，但人类在从给定集合中选择随机值方面尤其糟糕。

接下来，当 API 用户想要选择自己的标识符时，他们往往会做出错误的决定，例如: 将个人身份信息放入标识符本身。换句话说，有人可能会创建一个标识符为 pad(```base32Encode("harry-potter-8")```)（相当于 ```D1GQ4WKS5NR6YX3MCNS2TE05===```）的书，显然，作者想对世界保密。但是，这可能很困难，因为大多数系统不会将 ID（甚至 Base32 编码的 ID）视为秘密信息。相反，标识符通常被视为要使用的不透明的、随机的数据片段，但最方便。这意味着它们通常被认为可以安全地存储在日志文件中并与任何人共享。这包括在办公室周围的大仪表板上显示这些 ID，突出显示单个资源的潜在错误或统计数据。如果 API 允许用户选择标识符，那么可能有一天，大客户（或政府）要求对某些 ID 保密，这可能非常困难（甚至不可能）实现。

最后，我们对标识符的最后一个要求是它们是不可预测的（参见第 6.2.5 节）。正如我们之前提到的，虽然你的 API 的用户肯定有可能具有密码学或伪随机数生成器的背景，但通常情况并非如此。因此，要求用户选择他们自己的标识符可能会有问题。在最好的情况下，如果需要，它可能会很烦人（"你为什么不能为我想出一个 ID？"），但在最坏的情况下，它可能很危险，即使这是一个可选功能。特别是，这为用户提供了生成可预测标识符的机会，使他们成为安全错误的容易攻击目标。

#### 伪随机数发生器
就像大多数编程问题一样，我们有几种不同的方法来生成随机标识符。一种选择是使用加密安全的随机字节生成器（例如: Node.js 的 crypto.randomBytes() 函数）并将其转换为 Crockford 的 Base32（例如: 使用 Node.js 的 base32-encode 包）。另一种选择是使用随机选择算法从 Crockford 的 Base32 字母表中选择一定数量的字符。这些都不一定对或错，只是不同。

前者侧重于随机选择的标识符所涉及的字节数（选择一个 ID，因为它将存储在数据库中），而后者更关心面向用户的标识符（选择一个 ID，因为用户将实际看到它） .只要你提前进行数学计算，知道你希望你的字节表示多少个字符或你选择的字符需要在你的数据库中保留多少个字节，任何一个都是合理的。

数学本身非常简单，因为我们只是在 8 位字节和 5 位字符之间进行转换。这意味着对于 ID 中的每个数据字节，每个字节的 8 位必须由能够容纳 5 位的字符表示。简而言之，这意味着 ```base32Length == Math.ceil(bytes * 8 / 5)```。

出于说明目的，让我们看看如何生成专注于字节优先的随机标识符。

清单 6.1 生成随机的 Base32 编码标识符

```typescript
const crypto = require('crypto');
const base32Encode = require('base32-encode');
 
function generateId(sizeBytes: number): string {   // ❶    
  const bytes = crypto.randomBytes(sizeBytes);     // ❷
  return base32Encode(bytes, 'Crockford');         // ❸
}
```

❶ 这里，sizeBytes 是 ID 中的字节数。
❷ 首先生成一些随机字节。
❸ 返回 Crockford Base32 编码。
现在我们知道如何生成一个 ID，我们需要确保这个 ID 在 6.4.3 中没有被使用（而且在过去也没有被使用过）。 让我们简要地看看我们如何做到这一点。

### 6.4.3 石碑
正如我们在关于标识符持久性的部分中了解到的，在 API 的整个生命周期中，标识符的使用次数不得超过一次，这一点至关重要。这意味着即使在删除资源后，我们也不能重用相同的标识符。有很多方法可以做到这一点，有些方法需要比其他方法更多的存储空间。

一种简单的选择是依靠软删除的想法（在第 25 章中讨论）。在这种设计模式中，我们可以简单地将资源标记为已删除，而不是实际完全删除资源及其数据（"硬删除"）。然后，从我们的标识符生成代码的角度来看，我们只是继续生成随机值，直到我们遇到一个尚未被采用的值，并在此过程中检查我们的数据库以确保 ID 实际可用。尽管无论我们是否关心墓碑式标识符，这种模式都是有用的，但它存在不可预测的执行时间的古老问题，随着越来越多的标识符被创建和可用的 ID 集，这种问题在统计上只会变得更糟用完。也就是说，对于 120 位标识符，密钥空间的大小与地球上存在的细菌细胞数量大致相同。这意味着两次选择相同的细胞有点像从地球上的所有细菌细胞中挑选一个，然后再次随机挑选完全相同的一个。换句话说，遇到碰撞应该是非常罕见的。

在依赖软删除模式没有意义的情况下（可能涉及的数据很重要，出于某种原因你必须清除它，例如监管要求），你还有很多其他选择。例如: 你可以仅将已在哈希映射中获取的标识符存储在某处，或者保留 Bloom 过滤器并在它们开始使用时将 ID 添加到该过滤器。也就是说，通过使用相对于你将创建的资源数量足够大的标识符并使用可靠且加密安全的随机源来生成你的标识符，仍然可以最好地避免冲突。

### 6.4.4 校验和
如第 6.3.4 节所述，计算校验和就像将我们的字节值视为整数并使用模 37 值作为校验和值一样简单。 这意味着我们将数字除以 37，并将余数用作校验和。 然而，有时代码胜于雄辩。 请注意，我们将依赖 BigInt 类型来处理可能由任意长度的字节缓冲区产生的大整数。

清单 6.2 计算 Base32 校验和值

```typescript
function calculateChecksum(bytes: Buffer): number {
  const intValue = BigInt(`0x${bytes.toString('hex')}`);   // ❶
  return Number(intValue % BigInt(37));                    // ❷
}
```

❶ 首先将字节缓冲区转换为 BigInt 值。
❷ 通过确定除以 37 后的余数来计算校验和值。
此外，我们需要一种方法来将此校验和值编码为字符串（而不仅仅是数字值）。 为此，我们可以在标准 Base32 字母表的基础上添加五个附加字符：*、~、#、= 和 U（由于 Crockford 的 Base32 不区分大小写，因此在解析值时还包括 u）。 这样，由我们的校验和计算得出的任何值（范围从 0 到 36）都将有一个用于标识符的字符值。

清单 6.3 使用 Base37 字母表选择校验和值字符

```typescript
function getChecksumCharacter(checksumValue: number): string {
  const alphabet = '0123456789ABCDEFG' +
                   'HJKMNPQRSTVWXYZ*~$=U';    // ❶
  return alphabet[Math.abs(checksumValue)];   // ❷
}
```

❶ 定义字母表（Base32 加上五个附加字符）。
❷ 返回checksumValue 位置的字符。
此时，你可能想知道，"好吧，我有一个校验和字符。 怎么办？" 很简单，当向用户显示标识符时，我们可以将此字符附加到我们的 Base32 编码标识符的末尾，并且当提供标识符时，我们可以依赖此校验和字符是正确的。 让我们首先更新 generateId 函数以包含校验和字符。

清单 6.4 生成带有校验和字符的 Base32 标识符

```typescript
const crypto = require('crypto');
const base32Encode = require('base32-encode');
 
function generateIdWithChecksum(sizeBytes: number): string {
  const bytes = crypto.randomBytes(sizeBytes);
  const checksum = calculateChecksum(bytes);            // ❶
  const checksumChar = getChecksumCharacter(checksum);  // ❶
  const encoded = base32Encode(bytes, 'Crockford');
  return encoded + checksumChar;                        // ❷
}
```

❶ 计算校验和，得到正确的校验和字符。
❷ 返回带有校验和字符的 Base32 序列化标识符。
另一方面，我们应该将所有传入的标识符解析为两部分：标识符本身和校验和字符。 如果我们检查校验和字符并且结果是不正确的，这并不意味着校验和计算不正确。 这实际上意味着标识符本身可能存在拼写错误或其他错误，我们应该将标识符视为无效而拒绝。 为了看看这可能是如何工作的，清单 6.5 实现了一个 verifyIdentifier 函数，该函数返回一个布尔值，表示给定的标识符是否应该被认为是有效的。

清单 6.5 根据校验和值验证 Base32 标识符

```typescript
function verifyId(identifier: string): boolean {
  const value = identifier.substring(
      0, identifier.length-1);                             // ❶
  const checksumChar = identifier[identifier.length-1];
  const buffer = Buffer.from(
      base32Decode(value, 'Crockford'));                   // ❷
  return (getChecksumCharacter(calculateChecksum(buffer)) == checksumChar);  // ❸
}
```

❶ 将标识符分成两部分：值和校验和字符。
❷ 将 Base32 值解码为原始字节。
❸ 返回计算的校验和值是否等于提供的校验和值。
现在我们已经介绍了如何计算和验证校验和值，让我们继续从数据存储的角度来看所有这些是如何工作的。

### 6.4.5 数据库存储

对于我们所有关于不使用自动递增整数的讨论，大多数数据库都推荐这样做并为此进行了相当多的优化，这导致了一个明显的问题：如果我们使用这个新奇的随机 Base32 编码标识符，我们应该如何存储它以便我们的数据库不会因疲惫或混乱而崩溃？

首先，我们必须决定究竟需要在数据库中存储什么。显然标识符本身需要被存储，但是校验和字符呢？该值（以及我们在将其传递给用户时可能已编码到标识符中的任何其他元数据）不应存储在数据库中。相反，我们应该始终动态计算该值作为传入 ID 的验证步骤（并将其动态附加到传出 ID 上）。如果我们不得不更改用于计算校验和值的算法，知道我们不必遍历并重写数据库中的每个条目以反映新的校验和字符，这将是一种极大的解脱。

现在我们已经决定唯一要存储的数据是实际标识符，我们需要考虑如何存储它。我们如何存储这些数据有很多不同的选择，但我们将讨论三种不同的选择，从最简单的开始：字符串。

许多数据库（尤其是键值存储系统）非常擅长使用字符串值作为标识符。如果你碰巧使用其中之一，那么存储资源标识符将变得非常简单：你只需存储资源标识符的字符串表示，就像它对客户的显示一样（当然，在删除校验和字符之后）。这基本上是直接和简单的，所以如果你能摆脱这个选项，那就去做吧。还要记住，Crockford 的 Base32 编码保留了排序顺序，这意味着我们不应该有任何奇怪的情况，即数据库中的排序与客户端的排序不同。

不幸的是，并非所有数据库都像其他数据库一样擅长存储（和索引）字符串值。此外，在存储标识符的字符串表示时，你实际上是在浪费空间（因为每个 8 位字符仅表示 5 位实际数据）。考虑到这一点，我们始终可以使用可用的最低级别：存储原始字节。许多数据库非常擅长使用原始字节字段作为标识符。对于这些类型的数据库，我们可以依赖原始字节数据类型（例如: MySQL 调用此 BINARY）作为我们的主键，强制执行唯一性约束并添加索引，使单键查找查询快速而简单。

最后，如果我们正确选择了标识符的长度，我们可以调整它的长度，使其能够很好地适应常见的整数类型（例如: 32 位或 64 位）。如果可能，这可能是最好的选择，因为几乎所有数据库都非常擅长存储和索引数值。为此，我们只需将标识符表示的字节视为表示一个整数，我们在学习如何计算给定 ID（例如 ```byteBuffer.readBigInt64BEInt(0)```）的校验和值时看到了如何做。使用整数作为底层存储格式可能是最常用的支持选项，因为它几乎适用于所有数据库系统。

## 6.5 UUID 怎么样？
如果你不熟悉 UUID，跳过本节可能是安全的。简而言之，UUID 是具有相对悠久历史的常见 128 位标识符格式（规范 RFC-4122，日期为 2005 年 7 月）。 UUID 基本上是一种标准标识符格式，具有很多方便的功能，例如名称间距、大量可用 ID，因此冲突的可能性可以忽略不计。我们不会深入了解 UUID 的所有细节，但你可以通过它们的连字符格式识别它们，它们如下所示：```123e4567-e89b-12d3-a456-426655440000```。

如果你知道 UUID 是什么，并且你已经读到这里并且正在思考，"为什么我们不只是使用 UUID 并为此结束？"那么你并不孤单（一方面，如果是这样的话，跳过这一章会快得多）。简短的回答是，如果你需要 UUID，则完全没问题，但有三点值得一提，说明为什么我们没有用"只使用 UUID"这样的消息替换这一整章。

首先，UUID 很大（标识符空间总共 122 位，数据总共 128 位），这对于最常见的场景来说是多余的。在这种情况下，如果你知道不会创建数万亿的资源，你可能希望使用更短且更易于阅读的 ID 格式。

接下来，字符串格式的 UUID 在信息上并不那么密集，因为它们仅依赖于十六进制 (Base16) 表示法进行传输。简而言之，这意味着我们每个 ASCII 字符只携带 4 位信息，而我们使用 Base32 编码获得的每个字符有 5 位信息。虽然这对计算机来说可能并不重要（毕竟现在压缩非常好），但当我们需要通过非技术方式复制和共享这些时（例如: 通过电话共享标识符），高信息密度当然是一个不错的选择益处。

最后，根据定义，UUID 没有自己的校验和值。这意味着我们没有很好的方法来确定地区分丢失的 UUID 与不可能存在的 UUID（因此可能存在印刷错误）。在这种情况下，为标识符引入额外的校验和值是有意义的，以便我们可以区分这两种情况之间的区别，也许使用类似于 Base32 计算校验和字符的方法。

考虑到所有这些，在内部使用 UUID 值可能是有意义的，但仍将 Base32 字符串显示为面向客户的标识符。这使你可以从 UUID 提供的所有功能中受益，例如名称间距（UUID v3 和 v5）或基于时间戳的值（UUID v1 和 v2），以及 Base32 功能集，例如校验和值、可读性、和更高的信息密度。

你可以使用校验和字符生成 Base32 编码的 UUID v4（随机生成）。

清单 6.6 生成随机 Base32 编码的 UUID v4

```typescript
const base32Encode = require('base32-encode');
const uuid4 = require('uuid/v4');                         // ❶
 
function generateBase32EncodedUuid(): string {
  const b = Buffer.alloc(16);                             // ❷
  uuid4(null, b);                                         // ❸
  const checksum = calculateChecksum(b);                  // ❹
  const checksumChar = getChecksumCharacter(checksum);    // ❹
  return base32Encode(b, 'Crockford') + checksumChar;     // ❺
}
```

❶ 在这个例子中，我们在 NPM 上使用了 uuid 包。
❷ 首先分配一个 16 字节的缓冲区来保存 UUID。
❸ 生成 UUID（在本例中为随机 UUID v4）并将其存储在缓冲区中。
❹ 计算校验和，得到正确的Base37校验和字符。
❺ 返回 Crockford Base32 编码值（和校验和）。
如果我们有一个特别擅长存储和索引 UUID 的数据库，我们可能也想这样做，而不是像我们在 6.4.5 节中提到的那样将它们存储为字符串、原始字节或整数。

## 6.6 练习
- 设计一个新的编码和解码方案，具有更大的校验和大小，选择相对于标识符的大小。
- 计算随机选择的 2 字节（16 位）标识符发生冲突的可能性。 （提示：请参阅生日问题 1 作为指导。）
- 设计一种算法，在使用不依赖于单个计数器的 2 字节（16 位）标识符时避免冲突。 （提示：考虑分布式分配。）

## 总结

- 标识符是用于唯一指向 API 中特定资源的值。
- 好的标识符易于使用、唯一、永久、快速且易于生成、不可预测、可读、可复制、可共享和信息密集。
- 从客户的角度来看，标识符应该是字符串，使用 ASCII 字符集，最好依赖 Crockford 的 Base32 序列化格式。
- 标识符应该使用校验和字符来区分不存在的资源和永远不能指向资源的标识符（并且很可能是错误的结果）。
