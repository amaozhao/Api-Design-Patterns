本章涵盖内容

- 为什么我们要费心去关心命名
- 是什么让一些命名比其他的更好
- 如何在语言、语法和句法方面做出选择
- 上下文如何影响名称的含义
- 一个关于名称选择不当会发生什么的案例研究

不管我们喜不喜欢，命名无处不在。 在我们构建的每个软件系统以及我们设计或使用的每个 API 中，每个角落都隐藏着一些命名，它们的寿命比我们预期的要长得多。 正因为如此，选择好命名很重要（即使我们并不总是尽可能多地考虑我们的命名选择），这一点似乎很明显。 在本章中，我们将探索必须命名的 API 的不同组件、我们可以采用的一些策略来选择好命名、区分好命名和坏命名的高级属性，最后是一些一般原则 帮助指导我们做出不可避免的艰难命名决定。

## 3.1 为什么命名很重要？

在软件工程的世界中，几乎不可能避免为事物命名。如果可能的话，我们需要能够编写仅使用语言关键字（例如: class、for 或 if）的代码块，这充其量是不可读的。考虑到这一点，编译后的软件是一个特例。这是因为对于传统的编译代码，我们的函数和变量的名称只对那些有权访问源代码的人重要，因为名称本身通常在编译（或缩小）和部署期间消失。

另一方面，在设计和构建 API 时，我们选择的名称要重要得多，因为 API 的所有用户都会看到并与之交互。换句话说，这些名称不会简单地被编入并隐藏起来。这意味着我们需要对为 API 选择的名称进行大量的思考和考虑。

这里显而易见的问题变成了，"如果它们被证明是糟糕的选择，我们就不能改变命名吗？"正如我们将在第 24 章中学到的，在 API 中更改名称可能非常具有挑战性。想象一下，在源代码中更改一个常用函数的名称，然后意识到你需要进行大量的查找和替换，以确保更新了对该函数名称的所有引用。虽然不方便（甚至在某些 IDE 中很容易），但这当然是可能的。但是，请考虑此源代码是否可供公开使用以构建到他们自己的项目中。即使你可以以某种方式更新所有可用公共源代码的所有引用，也总会有你无权访问的私有源代码，因此不可能更新。

换句话说，在 API 中更改面向给那个开的命名有点像更改你的地址或电话号码。要在任何地方成功更改此号码，你必须联系所有知道你电话号码的人，包括你的祖母（她可能使用纸质地址簿）以及所有可以访问该号码的营销公司。即使你有办法与拥有你号码的每个人取得联系，你仍然需要他们来完成更新联系信息的工作，而他们可能太忙而无法完成。

既然我们已经看到了选择好命名（并避免改变它们）的重要性，这就引出了一个重要的问题：什么是"好"命名？

## 3.2 什么是"好"命名？

正如我们在第 1 章中了解到的，当 API 具有可操作性、表达性、简单性和可预测性时，它们就是"好"的。另一方面，名称非常相似，只是它们不一定具有可操作性（换句话说，名称实际上没有任何作用）。让我们看看这个属性子集和一些命名选择的例子，从表现力开始。

### 3.2.1 表现力

比其他任何事情都重要的是，一个命名能清楚地表达它所命名的东西是至关重要的。这个东西可能是一个函数或 RPC（例如: ```CreateAccount```）、一个资源或消息（例如: ```WeatherReading```）、一个字段或属性（例如: ```postal_address```），或者其他完全的东西，例如一个枚举值（例如: ```Color.BLUE``` )，但读者应该清楚这代表什么。这听起来可能很容易，但通常很难以全新的眼光看待一个命名，忘记我们随着时间的推移在特定领域工作所建立的所有背景。这种上下文通常是一笔巨大的资产，但在这种情况下，它更像是一种负担：它使我们不擅长命名。

例如: 术语主题通常用于异步消息传递（例如: Apache Kafka 或 RabbitMQ）；然而，它也用于机器学习和自然语言处理的特定领域，称为主题建模。如果你要在机器学习 API 中使用术语主题，那么用户可能会对你所指的主题类型感到困惑也就不足为奇了。如果确实有可能（也许你的 API 同时使用异步消息传递和主题建模），你可能希望选择比主题更具表现力的名称，例如 ```model_topic``` 或 ```messages_topic``` 以防止用户混淆。

### 3.2.2 简单

虽然一个富有表现力的命名当然很重要，但如果命名过长而没有增加额外的清晰度，它也会变得很麻烦。使用之前的示例（主题，指计算机科学的多个不同领域），如果一个 API 只涉及异步消息传递（例如: 类似 Apache Kafka 的 API）并且与机器学习无关，那么主题就足够了清晰简单，而messages_topic 不会增加太多价值。简而言之，名称应该具有表现力，但仅限于名称的每个附加部分都会增加价值以证明其存在的合理性。

另一方面，名称也不应该过于简单。例如: 假设我们有一个 API 需要存储一些用户指定的首选项。该资源可能称为 ```UserSpecifiedPreferences```；然而，```Specified``` 并没有给这个命名增加太多。另一方面，如果我们简单地调用资源首选项，则不清楚它们是谁的首选项，并且在需要存储和管理系统或管理员级别的首选项时可能会导致混淆。在这种情况下，```UserPreferences``` 似乎是表达名称和简单名称之间的最佳位置，总结在表 3.1 中。

表 3.1 在简单名称和表达名称之间进行选择

|           命名           |          说明          |
| :----------------------: | :--------------------: |
| UserSpecifiedPreferences | 富有表现力，但不够简单 |
|     UserPreferences      |   够简单，够有表现力   |
|       Preferences        |         太简单         |

### 3.2.3 可预测
既然我们已经在表现力和简单之间取得了平衡，那么选择一个好命名还有一个非常重要的最终方面：可预测性。 想象一个 API，它使用名称主题将相似的异步消息组合在一起（类似于 Apache Kafka）。 然后想象一下，API 在其他地方使用了名称 ```messages_topic```，而没有太多理由选择其中之一。 这会导致一些非常令人沮丧和不寻常的情况。

清单 3.1 由于命名不一致而令人沮丧的代码示例

```typescript
function handleMessage(message: Message) {
  if (message.topic == "budget.purge") {    // ❶    
    client.PurgeTopic({
      messagingTopic: "budget.update"       // ❷
    });
  }
}
```

❶ 这里我们使用名称主题来读取给定消息的主题。
❷ 这里我们使用名称 ```messagesTopic``` 来表示相同的概念。
在奇怪的情况下，这似乎并不令人沮丧，请考虑我们在这里违反的一个重要原则。一般来说，我们应该用同一个命名来代表同一个东西，用不同的命名来代表不同的东西。如果我们把这个原则当作公理，这就引出了一个重要的问题：主题与消息主题有什么不同？毕竟，我们使用了不同的名称，所以它们必须代表不同的概念，对吗？

基本的潜在目标是允许 API 的用户学习一个名称并继续建立在该知识的基础上，以便能够预测未来的名称（例如: 如果它们代表相同的概念）会是什么样子。当我们的意思是"给定消息的主题"时（当我们的意思是不同的时候），通过在整个 API 中一致地使用主题，我们允许 API 的用户建立在他们已经学到的东西的基础上，而不是混淆他们并强迫他们研究每一个命名，以确保它意味着他们所假设的。

现在我们已经了解了好命名的一些特征，让我们从语言、语法和句法的基本方面开始，探索一些在 API 中命名事物时可以作为护栏的通用指南。

## 3.3 语言、语法和句法
虽然代码都是关于 1 和 0，从根本上存储为数字，但命名是我们使用语言表达的主要主观构造。编程语言对什么是有效的，什么是无效的有非常严格的规则，不同的是，语言已经演变为比计算机更多地为人们服务，这使得规则变得不那么严格。这使我们的命名选择更加灵活和模糊，这可能是好事也可能是坏事。

一方面，歧义允许我们将事物命名为足够通用以支持未来的工作。例如: 命命名段 ```image_uri``` 而不是 ```jpeg_uri``` 可以防止我们将自己限制为单一图像格式 (JPEG)。另一方面，当同一件事有多种表达方式时，我们往往倾向于交替使用它们，这最终使我们的命名选择变得不可预测（参见第 3.2.3 节），并导致 API 令人沮丧和繁琐。为了避免这种情况，尽管"语言"具有相当大的灵活性，但通过强加我们自己的一些规则，我们可以避免失去我们在一个好的 API 中如此重视的可预测性。在本节中，我们将探索一些与语言相关的简单规则，这些规则可以帮助减少命名时必须做出的一些随意选择。

### 3.3.1 语言

虽然世界上有很多语言，但如果我们必须选择一种在软件工程中使用最多的语言，目前美国英语是主要的竞争者。这并不是说美式英语比其他语言更好或更差；然而，如果我们的目标是在世界范围内实现最大的互操作性，那么使用美式英语以外的任何语言都可能是一种障碍而不是一种好处。

这意味着应该使用英语语言概念（例如: ```BookStore``` 而不是 ```Librería```）并且通常应该首选常见的美式拼写（例如: 颜色而不是颜色）。这还有一个额外的好处，即几乎总是可以轻松地适应 ASCII 字符集，除了美国英语从其他语言（例如: 咖啡馆）借来的少数例外。

这并不意味着 API 注释必须是美式英语。如果 API 的受众完全位于法国，则提供法语文档（可能会或可能不会根据 API 规范注释自动生成）可能是有意义的。但是，使用 API 的软件工程师团队可能会使用其他 API，这些 API 不太可能专门针对法国客户。因此，它仍然认为，即使 API 的受众不使用美式英语作为他们的主要语言，API 本身仍应依赖美式英语作为所有使用大量不同 API 的各方共享的通用语言。

### 3.3.2 语法
鉴于 API 将使用美式英语作为标准语言，这会带来很多复杂的问题，因为英语并不是最简单的语言，具有许多不同的时态和语气。幸运的是，发音不会成为问题，因为源代码是一种书面语言而不是口语，但这并不一定能缓解所有潜在的问题。

本节将涉及一些最常见的问题，而不是试图规定美式英语语法的每一个方面，因为它适用于 API 中的命名。让我们从查看操作开始（例如: RPC 方法或 RESTful 动词）。

##### 紧急行动

在任何 API 中，都会有一些等同于编程语言的"函数"的东西，它们执行 API 预期的实际工作。这可能是一个纯粹的 RESTful API，它仅依赖于特定的预设操作列表（```Get```、```Create```、```Delete``` 等），那么你在这里没有太多事情要做，因为所有操作都将采用 \<StandardVerb><名词>（例如: ```CreateBook```）。对于允许非标准动词的非 RESTful 或面向资源的 API，我们有更多的选择来为这些操作命名。

REST 标准动词有一个重要的共同点：它们都使用祈使语气。换句话说，它们都是动词的命令或命令。如果这没有多大意义，想象一下陆军中士对你大喊大叫："创造那本书！" "删除那个天气读数！" "归档该日志条目！"尽管这些命令对军队来说很荒谬，但你确切地知道你应该做什么。

另一方面，有时我们编写的函数名称会带有指示性情绪。一个常见的例子是当一个函数正在调查某些东西时，例如 C# 中的 ```String.IsNullOrEmpty()```。在这种情况下，动词"to be"采用指示语气（询问有关资源的问题）而不是命令语气（命令服务做某事）。

虽然我们的函数具有这种情绪并没有什么根本性的错误，但当在 Web API 中使用时，它留下了一些重要的问题没有答案。首先，对于看起来可以在不询问远程服务的情况下处理的事情，"```isValid()``` 实际上会导致远程调用还是在本地处理？"虽然我们希望用户假设所有方法调用都是通过网络进行的，但让看似无状态的调用这样做有点误导。

其次，响应应该是什么样的？以调用 ```isValid()``` 的 RPC 为例。它是否应该返回一个简单的布尔字段来说明输入是否有效？如果该输入无效，它是否应该返回错误列表？另一方面，```GetValidationErrors()``` 更清晰：如果输入完全有效则返回空列表，否则返回错误列表。关于响应将采取的形状没有真正的混淆。

##### 介词

选择名称时的另一个混淆领域集中在介词上，例如"with"、"to"或"for"。虽然这些词在日常对话中非常有用，但在 Web API 的上下文中使用时，尤其是在资源名称中时，它们可能表示 API 更复杂的潜在问题。

例如: Library API 可能有一种列出图书资源的方法。如果此 API 需要一种方法来列出图书资源并包含负责该图书的作者资源，则可能很想为此组合创建一个新资源：```BookWithAuthor```（然后通过调用 ```ListBooksWithAuthors``` 或类似方法列出）。乍一看这似乎不错，但是当我们需要列出嵌入了 ```Publisher``` 资源的 ```Book``` 资源时呢？还是作者和出版商资源？在我们知道之前，我们将有 30 个不同的 RPC 调用，具体取决于我们想要的不同相关资源。

在这种情况下，我们想要在名称中使用的介词（"with"）表明了一个更基本的问题：我们想要一种列出资源并在响应中包含不同属性的方法。我们可能会使用字段掩码或视图（参见第 8 章）来解决这个问题，同时避免使用这种命名奇怪的资源。在这种情况下，介词表明有时不太正确。因此，即使介词可能不应该被完全禁止（例如: 一个字段可能被称为 ```bits_per_second```），但这些棘手的小词有点像代码气味，暗示某些事情不太正确，值得进一步研究。

##### 多元化

大多数情况下，我们会将 API 中的事物的名称选择为单数形式，例如 ```Book```、```Publisher``` 和 ```Author```（而不是 ```Books```、```Publishers``` 或 ```Authors```）。此外，这些名称选择往往通过 API 具有新的含义和目的。例如: ```Book``` 资源可能会被称为 ```Author.favoriteBook``` 的字段在某处引用（参见第 13 章）。然而，当我们需要谈论这些资源的倍数时，事情有时会变得混乱。更复杂的是，如果 API 使用 RESTful URL，一堆资源的集合名称几乎总是复数。例如: 当我们请求单个 Book 资源时，URL 中的集合名称几乎肯定会类似于 ```/books/1234```。

对于我们用作示例的名称（例如 ```Book```），这不是什么大问题；毕竟，提及多个 ```Book``` 资源只需添加一个"s"将名称复数化为 ```Books```。然而，有些命名并不那么简单。例如: 假设我们正在为足科医生办公室（足科医生）制作 API。当我们有一个 ```Foot``` 资源时，我们需要打破这种只添加一个"s"的模式，导致一个 ```feet``` 集合。

这个例子当然打破了模式，但至少它是清晰和明确的。如果我们的 API 与人打交道并因此拥有 Person 资源会怎样。是收藏者吗？还是人？换句话说，是否应该通过访问类似于 ```/persons/1234``` 或 ```/people/1234``` 的 URL 来检索 ```Person(id=1234)？```幸运的是，我们关于使用美式英语的指南给出了一个答案：使用人。

其他情况更令人沮丧。例如: 假设我们正在为水族馆开发 API。八达通资源的集合是什么？如你所见，我们对美式英语的选择有时会反过来咬我们。但最重要的是我们选择一个模式并坚持下去，这通常涉及快速搜索语法学家所说的正确内容（在这种情况下，"章鱼"完全没问题）。这也意味着我们永远不应该假设只需添加一个"s"就可以创建资源的复数形式——这是软件工程师寻找模式的常见诱惑。

### 3.3.3 语法
我们已经达到了命名的更多技术方面。与我们之前研究过的方面一样，在语法方面也有相同的指导方针。首先，选择一些东西并坚持下去。其次，如果有现有的标准（例如: 美式英语拼写），请使用该标准。那么这在实际意义上意味着什么呢？让我们从案例开始。

##### 案例

当我们定义一个 API 时，我们需要命名各种组件，比如资源、RPC 和字段。对于其中的每一个，我们倾向于使用不同的大小写，这有点像呈现名称的格式。大多数情况下，这种渲染仅在多个单词如何串在一起形成单个词汇单元时才明显。例如: 如果我们有一个字段代表一个人的命名，我们可能需要将该字段称为"命名"。然而，在几乎所有的编程语言中，空格都是词法分隔符，因此我们需要将"命名"组合成一个单元，这为许多不同的选项打开了大门，例如"骆驼案例"、"蛇案例"、 "或"烤肉串"。

在骆驼的情况下，单词通过将第一个之后的所有单词的字母大写来连接，因此"命名"将呈现为 ```firstName```（它的大写字母像骆驼一样的驼峰）。在蛇的情况下，单词使用下划线字符连接，如 ```first_name``` （它看起来有点像一条蛇）。在 ```kebab``` 的情况下，单词与连字符连接，就像命名一样（看起来有点像串起不同单词的烤肉串）。根据用于表示 API 规范的语言，不同的组件在不同的情况下呈现。例如: 在 Google 的 Protocol Buffer 语言中，标准是消息（如 TypeScript 接口）使用大写驼峰，如 ```UserSettings```（注意大写"U"）和蛇形大小写的字段名称，如 ```first_name```。另一方面，在开放 API 规范标准中，字段名称采用驼峰式大小写，如 ```firstName```。

如前所述，只要始终一致地使用这些选择，特定的选择并不是那么重要。例如: 如果你要为协议缓冲区 (https://developers.google.com/protocol-buffers) 消息使用名称 ```user_settings```，很容易认为这实际上是一个字段名称而不是一个信息。因此，这可能会给使用 API 的任何人造成混淆。说到类型，让我们花点时间来看看保留字。

##### 保留关键字
在大多数 API 定义语言中，都有一种方法可以指定存储在特定属性中的数据的类型。例如: 我们可能会说 ```firstName: string``` 以在 TypeScript 中表示名为 ```firstName``` 的字段包含一个原始字符串值。这也意味着术语 ```string``` 有一些特殊的含义，即使在代码中的不同位置使用。因此，在 API 中使用受限关键字作为名称可能很危险，应尽可能避免。

如果这看起来很困难，那么花一些时间思考一个字段或消息真正代表什么而不是最简单的选择是值得的。例如: 你可能想尝试使用更具体的术语，例如"发送者"和"接收者"（如果 API 是关于消息) 或者可能是"付款人"和"收款人"（如果 API 是关于付款的）。

考虑 API 的目标受众也很重要。例如: 如果 API 将只在 JavaScript 中使用（也许它旨在专门在 Web 浏览器中使用），那么其他语言（例如 Python 或 Ruby）中的关键字可能不值得担心。也就是说，如果工作量不大，最好避免使用其他语言中的关键字。毕竟，你永远不知道你的 API 何时最终会被其中一种语言使用。

现在我们已经了解了其中的一些技术方面，让我们跳上一个层次，谈谈我们的 API 存在和运行的上下文如何影响我们选择的名称。

## 3.4 上下文
虽然名称本身有时可以传达有用的所有必要信息，但我们通常依赖名称用于辨别其含义和预期用途的上下文。例如: 当我们在 API 中使用术语 ```book``` 时，我们可能指的是位于 Library API 中的资源；但是，我们也可能指的是要在 Flight Reservation API 中执行的操作。可以想象，相同的词和术语可能意味着完全不同的事物，具体取决于它们使用的上下文。这意味着在为 API 选择名称时，我们需要牢记 API 所处的上下文。

重要的是要记住这是双向的。一方面，上下文可以为可能缺乏特定含义的名称赋予附加价值。另一方面，当我们使用具有非常具体含义但在给定上下文中不太有意义的名称时，上下文可能会使我们误入歧途。例如: 名称"record"在没有任何上下文的情况下可能不是很有用，但在音频录制 API 的上下文中，该术语吸收了 API 的一般上下文赋予的额外含义。

简而言之，虽然对于如何在给定上下文中命名事物没有严格的规则，但要记住的重要一点是，我们在 API 中选择的所有名称都与该 API 提供的上下文密不可分。因此，在选择名称时，我们应该认识到该上下文及其可能赋予的含义（无论好坏）。

让我们稍微改变方向，谈谈数据类型和单位，特别是它们应该如何参与我们选择的名称。

## 3.5 数据类型和单位
虽然许多字段名称是没有单位的描述性名称（例如: ```firstName: string```），但其他字段名称没有单位可能会非常混乱。 例如: 想象一个名为"size"的字段。 根据上下文（参见第 3.4 节），该字段可能具有完全不同的含义，但也可能具有完全不同的单位。 我们可以看到相同的字段（大小）会完全不同，并且在许多情况下会混淆含义和单位。

清单 3.2 使用大小字段的音频剪辑和图像

```typescript
interface AudioClip {
  content: string;    // ❶
  size: number;       // ❷
}
 
interface Image {
  content: string;    // ❶    
  size: number;       // ❷
}
```

❶ 这可能包含 Base64 编码的二进制音频内容。
❷ 这个字段的单位比较混乱。 它是以字节为单位的大小吗？ 或者音频的持续时间（以秒为单位）？ 或者图像的尺寸？ 或者是其他东西？
在这个例子中，```size``` 字段可能有多种含义，但这些不同的含义也会导致非常不同的单位（例如: 字节、秒、像素等）。 幸运的是，这种关系是双向的，这意味着如果单位存在于某处，其含义将变得更加清晰。 换句话说，```sizeBytes``` 和 ```sizeMegapixels``` 比大小要清晰和明显得多。

清单 3.3 使用更清晰的大小字段和单位的音频剪辑和图像

```typescript
interface AudioClip {
  content: string;
  sizeBytes: number;       // ❶
}
 
interface Image {
  content: string;
  sizeMegapixels: number;  // ❶
}
```

❶ 现在这些尺寸字段的含义更加清晰，因为提供了单位。
这是否意味着我们应该在所有场景中始终简单地包含任何给定字段的单位或格式？ 毕竟，在所示的情况下，这肯定会最大限度地减少任何混淆。 例如: 假设我们想以像素资源存储图像的尺寸以及以字节为单位的大小。 我们可能有两个字段，分别称为 ```sizeBytes``` 和 ```dimensionsPixels```。 但尺寸实际上不止一个数字：我们需要长度和宽度。 一种选择是使用字符串字段并具有某种众所周知的格式的维度。

清单 3.4 使用字符串字段以像素为单位存储尺寸的图像

```typescript
interface Image {
  content: string;
  sizeBytes: number;
 
  // The dimensions (in pixels). E.g., "1024x768".   ❶    
  dimensionsPixels: string;                          // ❷
}
```

❶ 字段的格式在字段本身的前导注释中表示。
❷ 字段的单位是清晰的（像素），但原始数据类型可能会造成混淆。
虽然这个选项在技术上是有效的并且很清楚，但它显示出对始终使用原始数据类型的一些痴迷，即使它们可能没有意义。 换句话说，就像有时名称中包含一个单元时名称会变得更清晰可用一样，有时名称会在使用更丰富的数据类型时变得更清晰。 在这种情况下，我们可以使用具有长度和宽度数值的 Dimensions 接口，而不是使用组合两个数字的字符串类型，名称中包含单位（像素）。

清单 3.5 具有依赖于更丰富数据类型的维度的图像

```typescript
interface Image {
  content: string;
  sizeBytes: number;
  dimensions: Dimensions;   // ❶    
}
 
interface Dimensions {
  lengthPixels: number;     // ❷
  widthPixels: number;
}
```

❶ 在这种情况下，维度字段名称不需要名称中的单位，因为更丰富的数据类型传达了含义。
❷ 字段的单位是清晰的（像素），没有任何特殊的字符串格式。
在这种情况下，维度字段的含义是清晰而明显的。 此外，我们不必解压字段本身的一些特殊结构细节，因为 ```Dimensions``` 接口已经为我们完成了这项工作。 当我们在 API 中选择名称时没有采取适当的谨慎措施时，让我们通过一些案例研究来结束这个命名主题。

## 3.6 案例研究：当你选择坏命名时会发生什么？

这些关于如何选择好命名的指南以及在选择过程中值得考虑的各个方面都很好，但可能值得看几个使用不太正确的命名的真实示例。此外，我们可以看到这些命名选择的最终结果以及它们可能导致的潜在问题。让我们从一个命名问题开始，其中忽略了一个微妙但重要的部分。

##### 微妙的意义

如果你走进一家 Krispy Kreme 甜甜圈店并要 10 个甜甜圈，你会期望 10 个甜甜圈，对吧？如果你只有 8 个甜甜圈，你会感到惊讶吗？也许如果你有 8 个甜甜圈，你会认为商店里的甜甜圈肯定已经没有了。立即获得 8 个甜甜圈，然后必须再要求 2 个甜甜圈才能获得所需的 10 个甜甜圈，这肯定是不对的。

相反，如果你只能要求最多 N 个甜甜圈怎么办。换句话说，你只能问收银员"我最多可以有 10 个甜甜圈吗？"你会得到任意数量的甜甜圈，但永远不会超过 10 个。（请记住，这可能会导致你得到零个甜甜圈！）突然间第一个甜甜圈店例子中的奇怪行为是有道理的。还是不方便（我还没有见过有这种点餐系统的甜甜圈店），但至少没有莫名其妙的惊喜。

在第 21 章中，我们将学习一种设计模式，该模式演示如何在列表标准方法操作期间以安全、清晰且可很好地扩展到大量资源的方式翻阅大量资源。事实证明，这种仅要求最大值（而不是确切数量）的专有能力正是分页模式的工作原理（使用 ```maxPageSize``` 字段）。

谷歌的人（由于历史原因）遵循所描述的分页模式，除了一个重要的区别：不是指定 ```maxPageSize``` 来表示"最多给我 N 个项目"，请求指定一个 pageSize。这三个缺失的字符会导致非常大的混乱，就像订购甜甜圈的人一样：他们认为他们要求的是一个确切的数字，但实际上他们只能要求一个最大的数字。

最常见的情况是，当有人要 10 件商品时，得到 8 件，并认为一定没有更多商品了（就像我们可能假设甜甜圈店没有甜甜圈一样）。事实上，情况并非如此：仅仅因为我们拿回了 8 个，并不意味着这家店的甜甜圈卖完了；这只是意味着他们必须在后面找到更多。这最终会导致 API 用户错过很多项目，因为他们在列表实际结束之前停止翻阅结果。

虽然这可能令人沮丧并导致一些不便，但让我们看一下混合字段中的单位所犯的更严重的错误。

##### 单位
早在 1999 年，美国宇航局就计划将火星气候轨道飞行器操纵到离地表约 140 英里的轨道上。他们进行了大量计算，以确定要施加什么样的冲击力才能使轨道飞行器进入正确的位置，然后执行机动。不幸的是，不久之后，该团队注意到轨道飞行器不在它应该在的地方。它不是在地表上方 140 英里处，而是远低于此高度。事实上，后来的计算似乎表明，轨道器将在距离地表 35 英里的范围内。可悲的是，轨道飞行器可以生存的最低高度是 50 英里。如你所料，低于该地板意味着轨道飞行器很可能在火星的大气层中被摧毁。

在随后的调查中，发现洛克希德马丁团队以美国标准单位（特别是 ```lbf-s``` 或磅力秒）生产输出，而 NASA 团队以 SI 单位（特别是 N-s 或牛顿秒）工作。快速计算表明 1 ```lbf-s``` 相当于 4.45 ```N-s```，这最终导致轨道飞行器获得所需冲击力的四倍以上，最终使其低于最低高度。

清单 3.6 一个（非常简化的）用于 MCO 计算的 API 示例

```typescript
abstract class MarsClimateOrbiter {
  CalculateImpulse(CalculateImpulseRequest):
      CalculateImpulseResponse;              // ❶
  CalculateManeuver(CalculateManeuverRequest):
      CalculateManeuverResponse;             // ❶    
}
 
interface CalculateImpulseResponse {
  impulse: number;                           // ❷
}
 
interface CalculateManeuverRequest {
  impulse: number;                           // ❷
}
```

❶ 为简洁起见，省略了```CalculateImpulseRequest``` 和```CalculateManeuverResponse``` 接口。
❷ 这里我们计算了冲量，但没有单位！ 这意味着我们可以将前一个输出作为下一个输入。
另一方面，如果积分点在字段名称中包含单位，则错误会更加明显。

清单 3.7 修改示例接口以包含单元

```typescript
interface CalculateImpulseResponse {
  impulsePoundForceSeconds: number;   // ❶    
}
 
interface CalculateManeuverRequest {
  impulseNewtonSeconds: number;       // ❶
}
```

❶ 很明显，由于单位不同，你不能只获取一个 API 方法的输出并将其提供给下一个方法。
显然，火星气候轨道飞行器是一个比这里描述的要复杂得多的软件和机器，而且不太可能仅仅通过使用 更具描述性的名称。 也就是说，它很好地说明了为什么描述性名称很有价值，并且可以帮助突出假设的差异，尤其是在不同团队之间进行协调时。

## 3.7 练习
- 想象一下，你需要创建一个 API 来管理重复性计划（"此事件每月发生一次"）。 一位高级工程师认为，对于所有用例来说，在事件之间存储秒值就足够了。 另一位工程师认为 API 应该为各种时间单位（例如: 秒、分、小时、天、周、月、年）提供不同的字段。 哪种设计涵盖了预期功能的正确含义并且是更好的选择？
- 在你的公司中，存储系统使用千兆字节作为度量单位（10^9^ 字节）。 例如: 在创建共享文件夹时，你可以通过设置 sizeGB = 10 来将大小设置为 10 GB。一个新的 API 正在启动，其中网络吞吐量以 Gibibits（2^30^ 位）为单位，并希望以 Gibibits 为单位设置带宽限制（ 例如: bandwidthLimitGib = 1）。 这是否太微妙的差异并可能使用户感到困惑？ 为什么或者为什么不？

## 总结

- 好的命名，就像好的 API 一样，简单、富有表现力且可预测。
- 当谈到语言、语法和句法（以及其他任意选择）时，正确的答案通常是选择一些东西并坚持下去。
- 名称中的介词通常是 API 气味，暗示一些更大的底层设计问题值得解决。
- 请记住，使用名称的上下文既会传递信息，也可能会产生误导。 选择名称时请注意适当的上下文。
- 包括原语的单位并依靠更丰富的数据类型来帮助传达名称中不存在的信息。